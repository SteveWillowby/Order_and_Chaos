#include "Graph.hpp"
#include <sstream>
#include <fcntl.h>
#include <unistd.h>
#include <sys/file.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <unistd.h>
#include <regex>

using namespace std;

const string Graph::AUTOGENEREATED_FILES_FOLDER = "autogenerated/";

const int Graph::NODE_TYPE_GENE  = 1;
const int Graph::NODE_TYPE_MIRNA = 2;


Graph& Graph::loadGraph(string name, Graph& g) {
    //g.maxsize = max;
    g.loadGwFile("networks/"+name+"/"+name+".gw");
    g.name = name;
    return g;
}

Graph& Graph::loadGraphFromPath(string path, string name, Graph& g, int multipartite){
    g.path = path;
    g.multipartite = multipartite;
    string format = path.substr(path.find_last_of('.')+1);
    string uncompressedFileExt = getUncompressedFileExtension(path);
    if(format == "mpel" || uncompressedFileExt == "mpel" || ((format == "el" || uncompressedFileExt == "el") && multipartite == 2)){
        Graph::loadFromMultipartiteEdgeList(path, name, g, multipartite);
    }
    else if(format == "gw" || uncompressedFileExt == "gw"){
        g.loadGwFile(path);
        g.name = name;
    }
    else if(format == "el" || uncompressedFileExt == "el"){
        Graph::loadFromEdgeListFile(path, name, g, false);
    }
    else if(format == "elw" || uncompressedFileExt == "elw"){
        g.parseFloatWeight = true;
        Graph::loadFromEdgeListFile(path, name, g, false);
    }
    else if(format == "lgf"){
        Graph::loadFromLgfFile(path, name, g, false);
    }
    else if(format == "xml"){
        Graph::loadFromGraphmlFile(path, name, g, false);
    }
    else if(format == "csv"){
        Graph::loadFromCsvFile(path, name, g, false);
    }
    else if(format == "gml"){
        Graph::loadFromGmlFile(path, name, g, false);
    }
    else
        throw runtime_error("Unsupported graph format: " + format);

    return g;
}

Graph& Graph::multGraph(string name, uint path, Graph& g) {
    g.multGwFile("networks/"+name+"/"+name+".gw", path);
    cout << "graph made" << endl;
    g.name = name;
    return g;
}
void Graph::setMaxGraphletSize(double number){
    if (number == 5) // Only options are 4 or 5
        Graph::maxGraphletSize = number;
    //Graph::computeGraphletDegreeVectors();
}

void Graph::serializeGraph(Graph& G, string outputName, bool bipartite, bool locked)
{
    bool multi_pairwise = false;
#if MULTI_PAIRWISE
    multi_pairwise = true;
#endif
    createFolder(serializedFilesFolder());
    string sentinel = serializedFilesFolder() + outputName + ".lock";
    int fd = open(sentinel.c_str(), O_RDWR | O_EXCL | O_CREAT, 744);

    if (fd != -1)
    {
        int lock = flock(fd, LOCK_EX | LOCK_NB);
        if (lock != 0)
        {
            close(fd);
            return;
        }
        string outName = serializedFilesFolder() + outputName + (bipartite ? "_bipartite" : "_UntypedNodes")
            + (locked ? "_Locked" : "_Unlocked") + (multi_pairwise ? "_Multi_pairwise" : "_Not_multi_pairwise") + ".bin";

        string tmpName = "/tmp/" + outputName + (bipartite ? "_bipartite" : "_UntypedNodes")
            + (locked ? "_Locked" : "_Unlocked") + (multi_pairwise ? "_Multi_pairwise" : "_Not_multi_pairwise") + ".bin" + to_string(getpid());

        ofstream ofs(tmpName, ofstream::binary | ofstream::out);

        if (ofs.is_open())
        {
            cereal::BinaryOutputArchive oArchive(ofs);
            oArchive(G);
            ofs.close();
            struct stat st;

            if (stat(outName.c_str(), &st) != 0)
            {
                string movecmd = string("mv") + string(" ") + tmpName + string(" ") + outName;
                int dummy = fd;
		fd = system(movecmd.c_str()); // shut the fucking compiler up
		fd = dummy;
            }
            else
            {
                remove(tmpName.c_str());
            }
        }

        remove(sentinel.c_str());
        flock(fd, LOCK_UN);
        close(fd);
    }
    cout << outputName << " serialized." << endl;
}

void Graph::serializeShadow(Graph& G)
{
    string sentinel = serializedFilesFolder() + name + ".lock";
    int fd = open(sentinel.c_str(), O_RDWR | O_EXCL | O_CREAT, 744);

    if (fd != -1)
    {
        int lock = flock(fd, LOCK_EX | LOCK_NB);
        if (lock != 0)
        {
            close(fd);
            return;
        }

        string outName = serializedFilesFolder() + name + "_NodeNameToIndexMap" + ".bin";
        string tmpName = outName + to_string(getpid());
        ofstream ofs(tmpName, ofstream::binary | ofstream::out);

        if (ofs.is_open())
        {
            cereal::BinaryOutputArchive oArchive(ofs);
            oArchive(nodeNameToIndexMap);
            ofs.close();
            rename(tmpName.c_str(), outName.c_str());
        }

        remove(sentinel.c_str());
        flock(fd, LOCK_UN);
        close(fd);
    }
}

void Graph::loadGraphFromBinary(Graph& g, string graphName, string lockFile, bool bipartite, bool lockedSameName)
{
    bool multi_pairwise = false;
#if MULTI_PAIRWISE
    multi_pairwise = true;
#endif

    bool locked = lockedSameName || lockFile.size() > 0;
    ifstream ifs(serializedFilesFolder() + graphName + (bipartite ? "_bipartite" : "_UntypedNodes")
        + (locked ? "_Locked" : "_Unlocked") + (multi_pairwise ? "_Multi_pairwise" : "_Not_multi_pairwise") + ".bin", ifstream::binary | ifstream::in);
    if (ifs.is_open()) {
        cereal::BinaryInputArchive iArchive(ifs);
        iArchive(g);
        ifs.close();
    }
    g.name = graphName;
    g.updateUnlockedGeneCount();
    cout << "\t" << g.name << " has been deserialized." << endl;
}


void Graph::loadFromLgfFile(string fin, string graphName, Graph& g, bool bipartite) {
    ifstream infile;
    infile.open(fin,ifstream::in);
    string line;
    unordered_set<string> record;
    size_t lineCount = 0;
    // This is a perfectly valid regular expression that mysteriously fails on some systems
    try {
	regex pattern("^(\\w+)(\\s+)(\\w+)(\\s+)(\\d+)(\\s+)(\\d+)(\\s*)$");

	while(!infile.eof()){
	    getline(infile,line);
	    
	    if(regex_match(line,pattern))
	    {
		int check = 0;
		int target_start =0;
		unsigned int i = 0;
		string start,target;
		while(i < line.length())
		{
		    if(isspace(line[i]) && check == 0){
			check = 1;
			start =  line.substr(0,i);
		    }
		    if(!isspace(line[i]) && check == 1){
			check = 2;
			target_start = i;
		    }
		    if(isspace(line[i]) && check == 2){
			check = 0;
			target = line.substr(target_start,i-target_start);
			record.insert(start);
			record.insert(target);
			lineCount++;
			break;
		    }
		    i++;
		}
	    }
	}
	infile.close();	

	const size_t nodeLen = record.size();
	const size_t vecLen = lineCount;
	cout << graphName << ": number of nodes = " << nodeLen << ", number of edges = " << vecLen << endl;

	g.name = graphName;
	g.geneCount = 0;
	g.miRNACount = 0;

	vector<string> nodes;
	nodes.reserve(nodeLen);
	unordered_map<string,uint> nodeName2IndexMap;
	nodeName2IndexMap.reserve(nodeLen);

	vector<vector<string> > edges;
	edges.reserve(vecLen);

	ifstream ifs;
	ifs.open(fin,ifstream::in);
	while(!ifs.eof()){
	getline(ifs,line);
	
	if(regex_match(line,pattern))
	{
		    vector<string> words;
		    words.reserve(2);
		    int check = 0;
		    int target_start =0;
		    unsigned int i = 0;
		    string start,target;
		    while(i < line.length())
			    {
				    if(isspace(line[i]) && check == 0){
					    check = 1;
					    start =  line.substr(0,i);
				    }
				    if(!isspace(line[i]) && check == 1){
					    check = 2;
					    target_start = i;
				    }
				    if(isspace(line[i]) && check == 2){
					    check = 0;
					    target = line.substr(target_start,i-target_start);
		    words.push_back(start);
		    words.push_back(target);
		    edges.push_back(words);
			    break;
			    }
			    i++;
		    }
		    }
	    }
	    ifs.close();	

	string node1s;
	string node2s;

	for(unsigned i = 0; i < vecLen; ++i){
	    node1s = edges[i][0];
	    node2s = edges[i][1];

	    if(nodeName2IndexMap.find(node1s) == nodeName2IndexMap.end()){
		nodeName2IndexMap[node1s] = nodes.size();
		nodes.push_back(node1s);
		if(bipartite){
		    g.nodeTypes.push_back(Graph::NODE_TYPE_GENE);//"gene");
		    g.geneIndexList.push_back(nodeName2IndexMap[node1s]);
		    ++g.geneCount;
		}
	    }

	   if(nodeName2IndexMap.find(node2s) == nodeName2IndexMap.end()){
		nodeName2IndexMap[node2s] = nodes.size();
		nodes.push_back(node2s);
		if(bipartite){
		    g.nodeTypes.push_back(Graph::NODE_TYPE_MIRNA);//"miRNA");
		    g.miRNAIndexList.push_back(nodeName2IndexMap[node2s]);
		    ++g.miRNACount;
		}
	    }
	}

#ifdef MULTI_PAIRWISE
	vector<vector<uint>> edgeList(vecLen, vector<uint> (3));
#else
	vector<vector<uint>> edgeList(vecLen, vector<uint> (2));
	vector<float> floatWeightList;
	if (g.parseFloatWeight) {
	    floatWeightList = vector<float>(vecLen, 0);
	}
#endif
	stringstream errorMsg;
	string edgeValue;
	uint index1;
	uint index2;
	unordered_map<string, unordered_map<string, uint>* > adjMatrix;

	for (uint i = 0; i < vecLen; ++i) {
#ifdef MULTI_PAIRWISE
	    if (edges[i].size() == 2) {
		edgeValue = '1';
	    }
	    else if (edges[i].size() == 3) {
		edgeValue = edges[i][2];
	    }
	    else {
		throw runtime_error("File not in edge-list format: "+fin);
	    }
    #else
	    if (g.parseFloatWeight) {
		if (edges[i].size() != 3)
		    throw runtime_error("File not in edge-list-weight format: "+fin);
		// Get float weight
		edgeValue = edges[i][2];
	    }
	    else if (edges[i].size() != 2) {
		throw runtime_error("File not in edge-list format: "+fin);
	    }
    #endif
	    node1s = edges[i][0];
	    node2s = edges[i][1];

	    // Detects self-looping edges.
	    if(node1s == node2s && !g.parseFloatWeight) {
		errorMsg << "self-loops not allowed in file '" << fin << "' node " << node1s << '\n';
		throw runtime_error(errorMsg.str().c_str());
	    }

	    // Detects duplicate edges.
	    unordered_map<string, uint> *adjTo1;
	    if(adjMatrix.count(node1s) == 0)
		adjMatrix[node1s] = new unordered_map<string, uint>();
	    adjTo1 = adjMatrix.at(node1s);

	    unordered_map<string, uint> *adjTo2;
	    if(adjMatrix.count(node2s) == 0)
		adjMatrix[node2s] = new unordered_map<string, uint>();
	    adjTo2 = adjMatrix.at(node2s);

	    if( (adjTo1->count(node2s) != 0) || (adjTo2->count(node1s) != 0) ) {
		uint dupEdgeLineNum = adjTo1->at(node2s);
		errorMsg << "duplicate edges not allowed in file\n" <<
		    "\t'" << fin << ":" << dupEdgeLineNum+1 << "' " << node1s << " - " << node2s << '\n' <<
		    "\t'" << fin << ":" << i+1              << "' " << node1s << " - " << node2s << '\n';
		throw runtime_error(errorMsg.str().c_str());
	    }else{
		(*adjTo1)[node2s] = i;
		(*adjTo2)[node1s] = i;
	    }

	    index1 = nodeName2IndexMap[node1s];
	    index2 = nodeName2IndexMap[node2s];
	    edgeList[i][0] = index1;
	    edgeList[i][1] = index2;
#ifndef MULTI_PAIRWISE
	    if (g.parseFloatWeight) {
		floatWeightList[i] = stof(edgeValue);
	    }
#else
	    edgeList[i][2] = stoi(edgeValue);
	    assert(edgeList[i][2] < (1L << 8*sizeof(MATRIX_UNIT)) -1 ); // ensure type is large enough
#endif
	}
	for(auto itr : adjMatrix) { delete itr.second; }

	nodes.shrink_to_fit();
	const size_t nodeSize = nodes.size();
	g.adjLists = vector<vector<uint> > (nodeSize, vector<uint>(0));
	g.matrix = Matrix<MATRIX_UNIT>(nodeSize);
	if (g.parseFloatWeight) {
	    g.floatWeights = Matrix<float>(nodeSize);
	}
	uint node1;
	uint node2;
	const size_t edgeListLen = edgeList.size();
	edgeList.shrink_to_fit();
	for(unsigned i = 0; i < edgeListLen; ++i){
	    node1 = edgeList[i][0];
	    node2 = edgeList[i][1];

	    if(g.matrix[node1][node2] || g.matrix[node2][node1]) {
		errorMsg << "duplicate edges not allowed (in either direction), node numbers are " << node1 << " " << node2 << '\n';
		      //unordered_map<uint,string> index2name = g.getIndexToNodeNameMap();
		      //errorMsg << "In graph[" << graphName << "]: duplicate edges not allowed (in either direction), node names are " <<
		//          index2name[node1] << " " << index2name[node2] << '\n';
		throw runtime_error(errorMsg.str().c_str());
	    }

	    if(node1 == node2 && !g.parseFloatWeight) {
	      errorMsg << "self-loops not allowed, node number " << node1 << '\n';
	      throw runtime_error(errorMsg.str().c_str());
	    }

	    // Note that when MULTI_PAIRWISE is on, the adjacency matrix contains full integers, not just bits.
	    #ifdef MULTI_PAIRWISE
		g.matrix[node1][node2] = g.matrix[node2][node1] = edgeList[i][2];
	    #else
		g.matrix[node1][node2] = g.matrix[node2][node1] = true;
		if (g.parseFloatWeight) {
		    g.floatWeights[node1][node2] = g.floatWeights[node2][node1] = floatWeightList[i];
		}
	    #endif
	    g.adjLists[node1].push_back(node2);
	    g.adjLists[node2].push_back(node1);
	}
	// init rest of graph
	g.lockedList = vector<bool> (nodeSize, false);
	g.lockedTo = vector<string> (nodeSize, "");
	g.nodeNameToIndexMap = nodeName2IndexMap;
	g.edgeList = edgeList;
	if(bipartite)
	    g.updateUnlockedGeneCount();
	g.initConnectedComponents();
    }
    catch (std::regex_error& e) { 
	std::cerr << "Sorry, regex is broken on your system, can't load LGF file\n";
	exit(1);
    }
}



void Graph::loadFromGraphmlFile(string fin, string graphName, Graph& g, bool bipartite) {
    ifstream infile(fin.c_str());
    string line;
    unordered_set<string> record;
    size_t lineCount = 0;

    regex source("(.*)(source)(.*)");
    regex target("(.*)(target)(.*)");
    while (infile.good()) {

	getline (infile,line);
	if(regex_match(line,source))
	{
		size_t  s_place = line.find("source=");
		string re = line.substr(s_place);
		int n = 7;
		if(re[7] == '"')
			n++;
		string sub = re.substr(n);
		char f = ' ';
                if(n == 8)
			f = '"';
		string final_source;
		for(string::iterator it=sub.begin(); it!=sub.end(); ++it)
		{
			if(*it == f)
				break;
			final_source.push_back(*it);
			
		}
		size_t  t_place = re.find("target=");
		string t_re = re.substr(t_place);
		int x = 7;
		if(t_re[7] == '"')
			x++;
		string t_sub = t_re.substr(n);
		string final_target;
		for(string::iterator tit=t_sub.begin(); tit!=t_sub.end(); ++tit)
		{
			if(*tit == f || *tit == '>'||*tit == '/' )
				break;
			final_target.push_back(*tit);
			
		}
		record.insert(final_source);
		record.insert(final_target);
		lineCount++;

  	  }}
	
    infile.close();
    const size_t nodeLen = record.size();
    const size_t vecLen = lineCount;
    cout << graphName << ": number of nodes = " << nodeLen << ", number of edges = " << vecLen << endl;
    g.name = graphName;
    g.geneCount = 0;
    g.miRNACount = 0;

    vector<string> nodes;
    nodes.reserve(nodeLen);
    unordered_map<string,uint> nodeName2IndexMap;
    nodeName2IndexMap.reserve(nodeLen);

    vector<vector<string> > edges;
    edges.reserve(vecLen);
  
    ifstream ifs(fin);
    while (ifs.good()) {

	getline (ifs,line);
	if(regex_match(line,source))
	{
		vector<string> words;
                words.reserve(2);

		size_t  s_place = line.find("source=");
		string re = line.substr(s_place);
		int n = 7;
		if(re[7] == '"')
			n++;
		string sub = re.substr(n);
		char f = ' ';
                if(n == 8)
			f = '"';
		string final_source;
		for(string::iterator it=sub.begin(); it!=sub.end(); ++it)
		{
			if(*it == f)
				break;
			final_source.push_back(*it);
			
		}
		size_t  t_place = re.find("target=");
		string t_re = re.substr(t_place);
		int x = 7;
		if(t_re[7] == '"')
			x++;
		string t_sub = t_re.substr(n);
		string final_target;
		for(string::iterator tit=t_sub.begin(); tit!=t_sub.end(); ++tit)
		{
			if(*tit == f || *tit == '>'||*tit == '/' )
				break;
			final_target.push_back(*tit);
			
		}
		words.push_back(final_source);
		words.push_back(final_target);
		edges.push_back(words);
  	  }}
	
    ifs.close();


    string node1s;
    string node2s;

    for(unsigned i = 0; i < vecLen; ++i){
        node1s = edges[i][0];
        node2s = edges[i][1];

        if(nodeName2IndexMap.find(node1s) == nodeName2IndexMap.end()){
            nodeName2IndexMap[node1s] = nodes.size();
            nodes.push_back(node1s);
            if(bipartite){
                g.nodeTypes.push_back(Graph::NODE_TYPE_GENE);//"gene");
                g.geneIndexList.push_back(nodeName2IndexMap[node1s]);
                ++g.geneCount;
            }
        }

       if(nodeName2IndexMap.find(node2s) == nodeName2IndexMap.end()){
            nodeName2IndexMap[node2s] = nodes.size();
            nodes.push_back(node2s);
            if(bipartite){
                g.nodeTypes.push_back(Graph::NODE_TYPE_MIRNA);//"miRNA");
                g.miRNAIndexList.push_back(nodeName2IndexMap[node2s]);
                ++g.miRNACount;
            }
        }
    }

#ifdef MULTI_PAIRWISE
    vector<vector<uint>> edgeList(vecLen, vector<uint> (3));
#else
    vector<vector<uint>> edgeList(vecLen, vector<uint> (2));
    vector<float> floatWeightList;
    if (g.parseFloatWeight) {
        floatWeightList = vector<float>(vecLen, 0);
    }
#endif
    stringstream errorMsg;
    string edgeValue;
    uint index1;
    uint index2;
    unordered_map<string, unordered_map<string, uint>* > adjMatrix;

    for (uint i = 0; i < vecLen; ++i) {
#ifdef MULTI_PAIRWISE
        if (edges[i].size() == 2) {
            edgeValue = '1';
        }
        else if (edges[i].size() == 3) {
            edgeValue = edges[i][2];
        }
        else {
            throw runtime_error("File not in edge-list format: "+fin);
        }
#else
        if (g.parseFloatWeight) {
            if (edges[i].size() != 3)
                throw runtime_error("File not in edge-list-weight format: "+fin);
            // Get float weight
            edgeValue = edges[i][2];
        }
        else if (edges[i].size() != 2) {
            throw runtime_error("File not in edge-list format: "+fin);
        }
#endif
        node1s = edges[i][0];
        node2s = edges[i][1];

        // Detects self-looping edges.
        if(node1s == node2s && !g.parseFloatWeight) {
            errorMsg << "self-loops not allowed in file '" << fin << "' node " << node1s << '\n';
            throw runtime_error(errorMsg.str().c_str());
        }

        // Detects duplicate edges.
        unordered_map<string, uint> *adjTo1;
        if(adjMatrix.count(node1s) == 0)
            adjMatrix[node1s] = new unordered_map<string, uint>();
        adjTo1 = adjMatrix.at(node1s);

        unordered_map<string, uint> *adjTo2;
        if(adjMatrix.count(node2s) == 0)
            adjMatrix[node2s] = new unordered_map<string, uint>();
        adjTo2 = adjMatrix.at(node2s);

        if( (adjTo1->count(node2s) != 0) || (adjTo2->count(node1s) != 0) ) {
            uint dupEdgeLineNum = adjTo1->at(node2s);
            errorMsg << "duplicate edges not allowed in file\n" <<
                "\t'" << fin << ":" << dupEdgeLineNum+1 << "' " << node1s << " - " << node2s << '\n' <<
                "\t'" << fin << ":" << i+1              << "' " << node1s << " - " << node2s << '\n';
            throw runtime_error(errorMsg.str().c_str());
        }else{
            (*adjTo1)[node2s] = i;
            (*adjTo2)[node1s] = i;
        }

        index1 = nodeName2IndexMap[node1s];
        index2 = nodeName2IndexMap[node2s];
        edgeList[i][0] = index1;
        edgeList[i][1] = index2;
#ifndef MULTI_PAIRWISE
        if (g.parseFloatWeight) {
            floatWeightList[i] = stof(edgeValue);
        }
#else
        edgeList[i][2] = stoi(edgeValue);
        assert(edgeList[i][2] < (1L << 8*sizeof(MATRIX_UNIT)) -1 ); // ensure type is large enough
#endif
    }
    for(auto itr : adjMatrix) { delete itr.second; }

    nodes.shrink_to_fit();
    const size_t nodeSize = nodes.size();
    g.adjLists = vector<vector<uint> > (nodeSize, vector<uint>(0));
    g.matrix = Matrix<MATRIX_UNIT>(nodeSize);
    if (g.parseFloatWeight) {
        g.floatWeights = Matrix<float>(nodeSize);
    }
    uint node1;
    uint node2;
    const size_t edgeListLen = edgeList.size();
    edgeList.shrink_to_fit();
    for(unsigned i = 0; i < edgeListLen; ++i){
        node1 = edgeList[i][0];
        node2 = edgeList[i][1];

        if(g.matrix[node1][node2] || g.matrix[node2][node1]) {
            errorMsg << "duplicate edges not allowed (in either direction), node numbers are " << node1 << " " << node2 << '\n';
	          //unordered_map<uint,string> index2name = g.getIndexToNodeNameMap();
	          //errorMsg << "In graph[" << graphName << "]: duplicate edges not allowed (in either direction), node names are " <<
            //          index2name[node1] << " " << index2name[node2] << '\n';
            throw runtime_error(errorMsg.str().c_str());
        }

        if(node1 == node2 && !g.parseFloatWeight) {
          errorMsg << "self-loops not allowed, node number " << node1 << '\n';
          throw runtime_error(errorMsg.str().c_str());
        }

        // Note that when MULTI_PAIRWISE is on, the adjacency matrix contains full integers, not just bits.
        #ifdef MULTI_PAIRWISE
            g.matrix[node1][node2] = g.matrix[node2][node1] = edgeList[i][2];
        #else
            g.matrix[node1][node2] = g.matrix[node2][node1] = true;
            if (g.parseFloatWeight) {
                g.floatWeights[node1][node2] = g.floatWeights[node2][node1] = floatWeightList[i];
            }
        #endif
        g.adjLists[node1].push_back(node2);
        g.adjLists[node2].push_back(node1);
    }
    // init rest of graph
    g.lockedList = vector<bool> (nodeSize, false);
    g.lockedTo = vector<string> (nodeSize, "");
    g.nodeNameToIndexMap = nodeName2IndexMap;
    g.edgeList = edgeList;
    if(bipartite)
        g.updateUnlockedGeneCount();
    g.initConnectedComponents();
}


void Graph::loadFromCsvFile(string fin, string graphName, Graph& g, bool bipartite) {
    ifstream infile(fin.c_str());
    string line;
    unordered_set<string> record;
    size_t lineCount = 0;

    regex pattern("(.*);(.*)");
    string source,target;
	while(!infile.eof()){
	        getline(infile,line);
		string start,target;
		if(regex_match(line,pattern)){
			size_t semi = line.find(";");
			target = line.substr(semi);
			start = line.substr(0,line.length()-target.length());
			target = target.substr(1,target.length()-1);
			record.insert(start);
			record.insert(target);
			lineCount++;
		}
	}
	infile.close();


    const size_t nodeLen = record.size();
    const size_t vecLen = lineCount;
    cout << graphName << ": number of nodes = " << nodeLen << ", number of edges = " << vecLen << endl;

    g.name = graphName;
    g.geneCount = 0;
    g.miRNACount = 0;

    vector<string> nodes;
    nodes.reserve(nodeLen);
    unordered_map<string,uint> nodeName2IndexMap;
    nodeName2IndexMap.reserve(nodeLen);

    vector<vector<string> > edges;
    edges.reserve(vecLen);

    ifstream ifs(fin.c_str());
	while(!ifs.eof()){
	        getline(ifs,line);
		string start,target;
		if(regex_match(line,pattern)){
			vector<string> words;
        		words.reserve(2);
			size_t semi = line.find(";");
			target = line.substr(semi);
			start = line.substr(0,line.length()-target.length());
			target = target.substr(1,target.length()-1);
			words.push_back(start);
			words.push_back(target);
			edges.push_back(words);
		}
	}
	ifs.close();

    string node1s;
    string node2s;

    for(unsigned i = 0; i < vecLen; ++i){
        node1s = edges[i][0];
        node2s = edges[i][1];

        if(nodeName2IndexMap.find(node1s) == nodeName2IndexMap.end()){
            nodeName2IndexMap[node1s] = nodes.size();
            nodes.push_back(node1s);
            if(bipartite){
                g.nodeTypes.push_back(Graph::NODE_TYPE_GENE);//"gene");
                g.geneIndexList.push_back(nodeName2IndexMap[node1s]);
                ++g.geneCount;
            }
        }

       if(nodeName2IndexMap.find(node2s) == nodeName2IndexMap.end()){
            nodeName2IndexMap[node2s] = nodes.size();
            nodes.push_back(node2s);
            if(bipartite){
                g.nodeTypes.push_back(Graph::NODE_TYPE_MIRNA);//"miRNA");
                g.miRNAIndexList.push_back(nodeName2IndexMap[node2s]);
                ++g.miRNACount;
            }
        }
    }

#ifdef MULTI_PAIRWISE
    vector<vector<uint>> edgeList(vecLen, vector<uint> (3));
#else
    vector<vector<uint>> edgeList(vecLen, vector<uint> (2));
    vector<float> floatWeightList;
    if (g.parseFloatWeight) {
        floatWeightList = vector<float>(vecLen, 0);
    }
#endif
    stringstream errorMsg;
    string edgeValue;
    uint index1;
    uint index2;
    unordered_map<string, unordered_map<string, uint>* > adjMatrix;

    for (uint i = 0; i < vecLen; ++i) {
#ifdef MULTI_PAIRWISE
        if (edges[i].size() == 2) {
            edgeValue = '1';
        }
        else if (edges[i].size() == 3) {
            edgeValue = edges[i][2];
        }
        else {
            throw runtime_error("File not in edge-list format: "+fin);
        }
#else
        if (g.parseFloatWeight) {
            if (edges[i].size() != 3)
                throw runtime_error("File not in edge-list-weight format: "+fin);
            // Get float weight
            edgeValue = edges[i][2];
        }
        else if (edges[i].size() != 2) {
            throw runtime_error("File not in edge-list format: "+fin);
        }
#endif
        node1s = edges[i][0];
        node2s = edges[i][1];

        // Detects self-looping edges.
        if(node1s == node2s && !g.parseFloatWeight) {
            errorMsg << "self-loops not allowed in file '" << fin << "' node " << node1s << '\n';
            throw runtime_error(errorMsg.str().c_str());
        }

        // Detects duplicate edges.
        unordered_map<string, uint> *adjTo1;
        if(adjMatrix.count(node1s) == 0)
            adjMatrix[node1s] = new unordered_map<string, uint>();
        adjTo1 = adjMatrix.at(node1s);

        unordered_map<string, uint> *adjTo2;
        if(adjMatrix.count(node2s) == 0)
            adjMatrix[node2s] = new unordered_map<string, uint>();
        adjTo2 = adjMatrix.at(node2s);

        if( (adjTo1->count(node2s) != 0) || (adjTo2->count(node1s) != 0) ) {
            uint dupEdgeLineNum = adjTo1->at(node2s);
            errorMsg << "duplicate edges not allowed in file\n" <<
                "\t'" << fin << ":" << dupEdgeLineNum+1 << "' " << node1s << " - " << node2s << '\n' <<
                "\t'" << fin << ":" << i+1              << "' " << node1s << " - " << node2s << '\n';
            throw runtime_error(errorMsg.str().c_str());
        }else{
            (*adjTo1)[node2s] = i;
            (*adjTo2)[node1s] = i;
        }

        index1 = nodeName2IndexMap[node1s];
        index2 = nodeName2IndexMap[node2s];
        edgeList[i][0] = index1;
        edgeList[i][1] = index2;
#ifndef MULTI_PAIRWISE
        if (g.parseFloatWeight) {
            floatWeightList[i] = stof(edgeValue);
        }
#else
        edgeList[i][2] = stoi(edgeValue);
        assert(edgeList[i][2] < (1L << 8*sizeof(MATRIX_UNIT)) -1 ); // ensure type is large enough
#endif
    }
    for(auto itr : adjMatrix) { delete itr.second; }

    nodes.shrink_to_fit();
    const size_t nodeSize = nodes.size();
    g.adjLists = vector<vector<uint> > (nodeSize, vector<uint>(0));
    g.matrix = Matrix<MATRIX_UNIT>(nodeSize);
    if (g.parseFloatWeight) {
        g.floatWeights = Matrix<float>(nodeSize);
    }
    uint node1;
    uint node2;
    const size_t edgeListLen = edgeList.size();
    edgeList.shrink_to_fit();
    for(unsigned i = 0; i < edgeListLen; ++i){
        node1 = edgeList[i][0];
        node2 = edgeList[i][1];

        if(g.matrix[node1][node2] || g.matrix[node2][node1]) {
            errorMsg << "duplicate edges not allowed (in either direction), node numbers are " << node1 << " " << node2 << '\n';
	          //unordered_map<uint,string> index2name = g.getIndexToNodeNameMap();
	          //errorMsg << "In graph[" << graphName << "]: duplicate edges not allowed (in either direction), node names are " <<
            //          index2name[node1] << " " << index2name[node2] << '\n';
            throw runtime_error(errorMsg.str().c_str());
        }

        if(node1 == node2 && !g.parseFloatWeight) {
          errorMsg << "self-loops not allowed, node number " << node1 << '\n';
          throw runtime_error(errorMsg.str().c_str());
        }

        // Note that when MULTI_PAIRWISE is on, the adjacency matrix contains full integers, not just bits.
        #ifdef MULTI_PAIRWISE
            g.matrix[node1][node2] = g.matrix[node2][node1] = edgeList[i][2];
        #else
            g.matrix[node1][node2] = g.matrix[node2][node1] = true;
            if (g.parseFloatWeight) {
                g.floatWeights[node1][node2] = g.floatWeights[node2][node1] = floatWeightList[i];
            }
        #endif
        g.adjLists[node1].push_back(node2);
        g.adjLists[node2].push_back(node1);
    }
    // init rest of graph
    g.lockedList = vector<bool> (nodeSize, false);
    g.lockedTo = vector<string> (nodeSize, "");
    g.nodeNameToIndexMap = nodeName2IndexMap;
    g.edgeList = edgeList;
    if(bipartite)
        g.updateUnlockedGeneCount();
    g.initConnectedComponents();
}



void Graph::loadFromGmlFile(string fin, string graphName, Graph& g, bool bipartite) {
    ifstream infile;
    infile.open(fin);
    string line;
    unordered_set<string> record;
    size_t lineCount = 0;
    regex source("(.*)(source)(.*)");
    string s,t;
    while (infile.good()) {
	getline (infile,line);
	
	if(regex_match(line,source))
		{
		s = line.substr(15);
		getline (infile,line);
		t = line.substr(15);
		record.insert(s);
		record.insert(t);
		lineCount++;
		}
   }
    infile.close();

    const size_t nodeLen = record.size();
    const size_t vecLen = lineCount;
    cout << graphName << ": number of nodes = " << nodeLen << ", number of edges = " << vecLen << endl;

    g.name = graphName;
    g.geneCount = 0;
    g.miRNACount = 0;

    vector<string> nodes;
    nodes.reserve(nodeLen);
    unordered_map<string,uint> nodeName2IndexMap;
    nodeName2IndexMap.reserve(nodeLen);

    vector<vector<string> > edges;
    edges.reserve(vecLen);

    ifstream ifs;
    ifs.open(fin);

    while (ifs.good()) {
	getline (ifs,line);
	if(regex_match(line,source))
		{
		vector<string> words;
        	words.reserve(2);
		s = line.substr(15);
		getline (ifs,line);
		t = line.substr(15);
		words.push_back(s);
		words.push_back(t);
		//cout << s <<  " " << t << endl;
		edges.push_back(words);
		}
   }
    ifs.close();

    string node1s;
    string node2s;

    for(unsigned i = 0; i < vecLen; ++i){
        node1s = edges[i][0];
        node2s = edges[i][1];

        if(nodeName2IndexMap.find(node1s) == nodeName2IndexMap.end()){
            nodeName2IndexMap[node1s] = nodes.size();
            nodes.push_back(node1s);
            if(bipartite){
                g.nodeTypes.push_back(Graph::NODE_TYPE_GENE);//"gene");
                g.geneIndexList.push_back(nodeName2IndexMap[node1s]);
                ++g.geneCount;
            }
        }

       if(nodeName2IndexMap.find(node2s) == nodeName2IndexMap.end()){
            nodeName2IndexMap[node2s] = nodes.size();
            nodes.push_back(node2s);
            if(bipartite){
                g.nodeTypes.push_back(Graph::NODE_TYPE_MIRNA);//"miRNA");
                g.miRNAIndexList.push_back(nodeName2IndexMap[node2s]);
                ++g.miRNACount;
            }
        }
    }

#ifdef MULTI_PAIRWISE
    vector<vector<uint>> edgeList(vecLen, vector<uint> (3));
#else
    vector<vector<uint>> edgeList(vecLen, vector<uint> (2));
    vector<float> floatWeightList;
    if (g.parseFloatWeight) {
        floatWeightList = vector<float>(vecLen, 0);
    }
#endif
    stringstream errorMsg;
    string edgeValue;
    uint index1;
    uint index2;
    unordered_map<string, unordered_map<string, uint>* > adjMatrix;

    for (uint i = 0; i < vecLen; ++i) {
#ifdef MULTI_PAIRWISE
        if (edges[i].size() == 2) {
            edgeValue = '1';
        }
        else if (edges[i].size() == 3) {
            edgeValue = edges[i][2];
        }
        else {
            throw runtime_error("File not in edge-list format: "+fin);
        }
#else
        if (g.parseFloatWeight) {
            if (edges[i].size() != 3)
                throw runtime_error("File not in edge-list-weight format: "+fin);
            // Get float weight
            edgeValue = edges[i][2];
        }
        else if (edges[i].size() != 2) {
            throw runtime_error("File not in edge-list format: "+fin);
        }
#endif
        node1s = edges[i][0];
        node2s = edges[i][1];

        // Detects self-looping edges.
        if(node1s == node2s && !g.parseFloatWeight) {
            errorMsg << "self-loops not allowed in file '" << fin << "' node " << node1s << '\n';
            throw runtime_error(errorMsg.str().c_str());
        }

        // Detects duplicate edges.
        unordered_map<string, uint> *adjTo1;
        if(adjMatrix.count(node1s) == 0)
            adjMatrix[node1s] = new unordered_map<string, uint>();
        adjTo1 = adjMatrix.at(node1s);

        unordered_map<string, uint> *adjTo2;
        if(adjMatrix.count(node2s) == 0)
            adjMatrix[node2s] = new unordered_map<string, uint>();
        adjTo2 = adjMatrix.at(node2s);

        if( (adjTo1->count(node2s) != 0) || (adjTo2->count(node1s) != 0) ) {
            uint dupEdgeLineNum = adjTo1->at(node2s);
            errorMsg << "duplicate edges not allowed in file\n" <<
                "\t'" << fin << ":" << dupEdgeLineNum+1 << "' " << node1s << " - " << node2s << '\n' <<
                "\t'" << fin << ":" << i+1              << "' " << node1s << " - " << node2s << '\n';
            throw runtime_error(errorMsg.str().c_str());
        }else{
            (*adjTo1)[node2s] = i;
            (*adjTo2)[node1s] = i;
        }

        index1 = nodeName2IndexMap[node1s];
        index2 = nodeName2IndexMap[node2s];
        edgeList[i][0] = index1;
        edgeList[i][1] = index2;
#ifndef MULTI_PAIRWISE
        if (g.parseFloatWeight) {
            floatWeightList[i] = stof(edgeValue);
        }
#else
        edgeList[i][2] = stoi(edgeValue);
        assert(edgeList[i][2] < (1L << 8*sizeof(MATRIX_UNIT)) -1 ); // ensure type is large enough
#endif
    }
    for(auto itr : adjMatrix) { delete itr.second; }

    nodes.shrink_to_fit();
    const size_t nodeSize = nodes.size();
    g.adjLists = vector<vector<uint> > (nodeSize, vector<uint>(0));
    g.matrix = Matrix<MATRIX_UNIT>(nodeSize);
    if (g.parseFloatWeight) {
        g.floatWeights = Matrix<float>(nodeSize);
    }
    uint node1;
    uint node2;
    const size_t edgeListLen = edgeList.size();
    edgeList.shrink_to_fit();
    for(unsigned i = 0; i < edgeListLen; ++i){
        node1 = edgeList[i][0];
        node2 = edgeList[i][1];

        if(g.matrix[node1][node2] || g.matrix[node2][node1]) {
            errorMsg << "duplicate edges not allowed (in either direction), node numbers are " << node1 << " " << node2 << '\n';
	          //unordered_map<uint,string> index2name = g.getIndexToNodeNameMap();
	          //errorMsg << "In graph[" << graphName << "]: duplicate edges not allowed (in either direction), node names are " <<
            //          index2name[node1] << " " << index2name[node2] << '\n';
            throw runtime_error(errorMsg.str().c_str());
        }

        if(node1 == node2 && !g.parseFloatWeight) {
          errorMsg << "self-loops not allowed, node number " << node1 << '\n';
          throw runtime_error(errorMsg.str().c_str());
        }

        // Note that when MULTI_PAIRWISE is on, the adjacency matrix contains full integers, not just bits.
        #ifdef MULTI_PAIRWISE
            g.matrix[node1][node2] = g.matrix[node2][node1] = edgeList[i][2];
        #else
            g.matrix[node1][node2] = g.matrix[node2][node1] = true;
            if (g.parseFloatWeight) {
                g.floatWeights[node1][node2] = g.floatWeights[node2][node1] = floatWeightList[i];
            }
        #endif
        g.adjLists[node1].push_back(node2);
        g.adjLists[node2].push_back(node1);
    }
    // init rest of graph
    g.lockedList = vector<bool> (nodeSize, false);
    g.lockedTo = vector<string> (nodeSize, "");
    g.nodeNameToIndexMap = nodeName2IndexMap;
    g.edgeList = edgeList;
    if(bipartite)
        g.updateUnlockedGeneCount();
    g.initConnectedComponents();
}

void Graph::loadFromMultipartiteEdgeList(string fin, string graphName, Graph& g, int multipartite) {
    unordered_set<string> record;
    size_t lineCount = 0;
    stdiobuf sbuf = readFileAsStreamBuffer(fin);
    istream infile(&sbuf);
    int numTypes = 0;
    
    g.typedNodesIndexList = vector<vector<uint>>{};
    for (string line; getline(infile, line); ) {
        string node1, node2;
        istringstream iss(line);
        string token;
        numTypes = 0;
        while(getline(iss, token, '\t')) {
            if(token.back() == 13)
                token = token.substr(0, token.size()-1);
            if(token != "-") {
                record.insert(token);
            }
            numTypes++;
        }
        ++lineCount;
    }
    
    for(int i = 0; i < numTypes; i++)
        g.typedNodesIndexList.push_back(vector<uint>{});

    const size_t nodeLen = record.size();
    const size_t vecLen = lineCount;
    cout << graphName << ": number of nodes = " << nodeLen << ", number of edges = " << vecLen << endl;
    
    g.name = graphName;
    g.nodeTypesCount.resize(numTypes);
    
#ifdef MULTI_PAIRWISE
    g.edgeList = vector<vector<uint>>(vecLen, vector<uint>(3));
#else
    g.edgeList = vector<vector<uint>>(vecLen, vector<uint>(2));
    if (g.parseFloatWeight) {
        g.floatWeights = Matrix<float>(nodeLen);
    }
#endif
    stringstream errorMsg;
    string edgeValue;
    uint index1;
    uint index2;
    unordered_map<string, unordered_map<string, uint>* > adjMatrix;
    g.nodeNameToIndexMap.reserve(nodeLen);

    checkFileExists(fin);
    stdiobuf sbuf2 = readFileAsStreamBuffer(fin);
    istream ifs(&sbuf2);
    size_t nodesCount = 0;
    string line;
    for (uint i = 0; getline(ifs, line); ++i) {
        istringstream iss(line);
        vector<string> words;
        vector<int> types;
        string token;
        int type = 0;
        while(getline(iss, token, '\t')){
            if(token.back() == 13)
                token = token.substr(0, token.size()-1);
            if(token != "-") {
                words.push_back(token);
                types.push_back(type);
            }
            type++;
        }
        
        string node1s = words[0];
        string node2s = words[1];
        
        int node1type = types[0];
        int node2type = types[1];
        
        
        
        if(g.nodeNameToIndexMap.find(node1s) == g.nodeNameToIndexMap.end()){
            g.nodeNameToIndexMap[node1s] = nodesCount;
            g.nodeTypesCount[node1type]++;
            g.nodeTypes.push_back(node1type);
            g.typedNodesIndexList[node1type].push_back(g.nodeNameToIndexMap[node1s]);
            nodesCount++;
        }
        if(g.nodeNameToIndexMap.find(node2s) == g.nodeNameToIndexMap.end()){
            g.nodeNameToIndexMap[node2s] = nodesCount;
            g.nodeTypesCount[node2type]++;
            g.nodeTypes.push_back(node2type);
            g.typedNodesIndexList[node2type].push_back(g.nodeNameToIndexMap[node2s]);
            nodesCount++;
        }
        
        #ifdef MULTI_PAIRWISE
                if (words.size() == 2) {
                    edgeValue = '1';
                }
                else if (words.size() == 3) {
                    edgeValue = words[2];
                }
                else {
                    throw runtime_error("File not in edge-list format: "+fin);
                }
        #else
                if (g.parseFloatWeight) {
                    if (words.size() != 3)
                        throw runtime_error("File not in edge-list-weight format: "+fin);
                    // Get float weight
                    edgeValue = words[2];
                }
                else if (words.size() != 2) {
                    throw runtime_error("File not in edge-list format: "+fin);
                }
        #endif
                /*------------------ Detects duplicate edges ------------------ */
                unordered_map<string, uint> *adjTo1;
                if(adjMatrix.count(node1s) == 0)
                    adjMatrix[node1s] = new unordered_map<string, uint>();
                adjTo1 = adjMatrix.at(node1s);
        
                unordered_map<string, uint> *adjTo2;
                if(adjMatrix.count(node2s) == 0)
                    adjMatrix[node2s] = new unordered_map<string, uint>();
                adjTo2 = adjMatrix.at(node2s);
        
                if( (adjTo1->count(node2s) != 0) || (adjTo2->count(node1s) != 0) ) {
                    uint dupEdgeLineNum = adjTo1->at(node2s);
                    errorMsg << "duplicate edges not allowed in file\n" <<
                        "\t'" << fin << ":" << dupEdgeLineNum+1 << "' " << node1s << " - " << node2s << '\n' <<
                        "\t'" << fin << ":" << i+1              << "' " << node1s << " - " << node2s << '\n';
                    throw runtime_error(errorMsg.str().c_str());
                }else{
                    (*adjTo1)[node2s] = i;
                    (*adjTo2)[node1s] = i;
                }
        
                /*------------------------ Fill edge list ------------------*/
                index1 = g.nodeNameToIndexMap[node1s];
                index2 = g.nodeNameToIndexMap[node2s];
                g.edgeList[i][0] = index1;
                g.edgeList[i][1] = index2;
                
        #ifdef MULTI_PAIRWISE
                g.edgeList[i][2] = stoi(edgeValue);
                assert(g.edgeList[i][2] < (1L << 8*sizeof(MATRIX_UNIT)) -1 ); // ensure type is large enough
        #endif
              /*----------------------------- Fill float weight ----------------------- */
              if (g.parseFloatWeight) {
                    g.floatWeights[index1][index2] = g.floatWeights[index2][index1] = stof(edgeValue);
              }
            }
            g.edgeList.shrink_to_fit();
            for(auto itr : adjMatrix) { delete itr.second; }
        
            /*----------------------------- Fill adjLists and matrix ------------------------- */
            g.adjLists = vector<vector<uint> > (nodeLen, vector<uint>(0));
            g.matrix = Matrix<MATRIX_UNIT>(nodeLen);
            uint node1;
            uint node2;
            for(unsigned i = 0; i < g.edgeList.size(); ++i){
                node1 = g.edgeList[i][0];
                node2 = g.edgeList[i][1];
        
                // Note that when MULTI_PAIRWISE is on, the adjacency matrix contains full integers, not just bits.
                #ifdef MULTI_PAIRWISE
                    g.matrix[node1][node2] = g.matrix[node2][node1] = g.edgeList[i][2];
                #else
                    g.matrix[node1][node2] = g.matrix[node2][node1] = true;
                #endif
        
                // Self-loop
                if(node1 == node2) {
                    g.adjLists[node1].push_back(node1);
                }else{
                    g.adjLists[node1].push_back(node2);
                    g.adjLists[node2].push_back(node1);
                }
            }
        
            /*------------------------------- Init rest of graph --------------------------------- */
            g.lockedList = vector<bool> (nodeLen, false);
            g.lockedTo = vector<string> (nodeLen, "");
            // if(bipartite)
            //     g.updateUnlockedGeneCount();
            g.initConnectedComponents();
    
}


void Graph::loadFromEdgeListFile(string fin, string graphName, Graph& g, bool bipartite) {
    unordered_set<string> record;
    size_t lineCount = 0;
    stdiobuf sbuf = readFileAsStreamBuffer(fin);
    istream infile(&sbuf);
    for (string line; getline(infile, line); ) {
        string node1, node2;
        istringstream iss(line);
        iss >> node1 >> node2;
        record.insert(node1);
        record.insert(node2);
        ++lineCount;
    }
    const size_t nodeLen = record.size();
    const size_t vecLen = lineCount;
    cout << graphName << ": number of nodes = " << nodeLen << ", number of edges = " << vecLen << endl;

    g.name = graphName;
    g.geneCount = 0;
    g.miRNACount = 0;


#ifdef MULTI_PAIRWISE
    g.edgeList = vector<vector<uint>>(vecLen, vector<uint>(3));
#else
    g.edgeList = vector<vector<uint>>(vecLen, vector<uint>(2));
    if (g.parseFloatWeight) {
        g.floatWeights = Matrix<float>(nodeLen);
    }
#endif
    stringstream errorMsg;
    string edgeValue;
    uint index1;
    uint index2;
    unordered_map<string, unordered_map<string, uint>* > adjMatrix;
    g.nodeNameToIndexMap.reserve(nodeLen);

    checkFileExists(fin);
    stdiobuf sbuf2 = readFileAsStreamBuffer(fin);
    istream ifs(&sbuf2);
    size_t nodesCount = 0;
    string line;
    unordered_map<uint,int> nodeToNeighborCount = unordered_map<uint,int>(nodeLen);
    for (uint i = 0; getline(ifs, line); ++i) {
        /*-------------------------- Parse -------------------------*/
        istringstream iss(line);
        vector<string> words;
        words.reserve(3);
        copy(istream_iterator<string>(iss), istream_iterator<string>(), back_inserter(words));
        string node1s = words[0];
        string node2s = words[1];

        /*---------------------- Fill into nodeNameToIndexMap -------*/
        if(g.nodeNameToIndexMap.find(node1s) == g.nodeNameToIndexMap.end()){
            g.nodeNameToIndexMap[node1s] = nodesCount;
            ++nodesCount;
            if(bipartite){
                g.nodeTypes.push_back(Graph::NODE_TYPE_GENE);//"gene");
                g.geneIndexList.push_back(g.nodeNameToIndexMap[node1s]);
                ++g.geneCount;
            }
        }

       if(g.nodeNameToIndexMap.find(node2s) == g.nodeNameToIndexMap.end()){
            g.nodeNameToIndexMap[node2s] = nodesCount;
            ++nodesCount;
            if(bipartite){
                g.nodeTypes.push_back(Graph::NODE_TYPE_MIRNA);//"miRNA");
                g.miRNAIndexList.push_back(g.nodeNameToIndexMap[node2s]);
                ++g.miRNACount;
            }
        }

#ifdef MULTI_PAIRWISE
        if (words.size() == 2) {
            edgeValue = '1';
        }
        else if (words.size() == 3) {
            edgeValue = words[2];
        }
        else {
            throw runtime_error("File not in edge-list format: "+fin);
        }
#else
        if (g.parseFloatWeight) {
            if (words.size() != 3)
                throw runtime_error("File not in edge-list-weight format: "+fin);
            // Get float weight
            edgeValue = words[2];
        }
        else if (words.size() != 2) {
            throw runtime_error("File not in edge-list format: "+fin);
        }
#endif
        /*------------------ Detects duplicate edges ------------------ */
        unordered_map<string, uint> *adjTo1;
        if(adjMatrix.count(node1s) == 0)
            adjMatrix[node1s] = new unordered_map<string, uint>();
        adjTo1 = adjMatrix.at(node1s);

        unordered_map<string, uint> *adjTo2;
        if(adjMatrix.count(node2s) == 0)
            adjMatrix[node2s] = new unordered_map<string, uint>();
        adjTo2 = adjMatrix.at(node2s);

        if( (adjTo1->count(node2s) != 0) || (adjTo2->count(node1s) != 0) ) {
            uint dupEdgeLineNum = adjTo1->at(node2s);
            errorMsg << "duplicate edges not allowed in file\n" <<
                "\t'" << fin << ":" << dupEdgeLineNum+1 << "' " << node1s << " - " << node2s << '\n' <<
                "\t'" << fin << ":" << i+1              << "' " << node1s << " - " << node2s << '\n';
            throw runtime_error(errorMsg.str().c_str());
        }else{
            (*adjTo1)[node2s] = i;
            (*adjTo2)[node1s] = i;
        }

        /*------------------------ Fill edge list ------------------*/
        index1 = g.nodeNameToIndexMap[node1s];
        index2 = g.nodeNameToIndexMap[node2s];
        g.edgeList[i][0] = index1;
        g.edgeList[i][1] = index2;
        nodeToNeighborCount[index1]++;
        nodeToNeighborCount[index2]++;
#ifdef MULTI_PAIRWISE
        g.edgeList[i][2] = stoi(edgeValue);
        assert(g.edgeList[i][2] < (1L << 8*sizeof(MATRIX_UNIT)) -1 ); // ensure type is large enough
#endif
      /*----------------------------- Fill float weight ----------------------- */
      if (g.parseFloatWeight) {
            g.floatWeights[index1][index2] = g.floatWeights[index2][index1] = stof(edgeValue);
      }
    }
    g.edgeList.shrink_to_fit();
    for(auto itr : adjMatrix) { delete itr.second; }

    /*----------------------------- Fill adjLists and matrix ------------------------- */
    g.adjLists = vector<vector<uint> > (nodeLen, vector<uint>(0));
    g.matrix = Matrix<MATRIX_UNIT>(nodeLen);
    g.matrix.reserve_inner(nodeToNeighborCount);
    uint node1;
    uint node2;
    for(unsigned i = 0; i < g.edgeList.size(); ++i){
        node1 = g.edgeList[i][0];
        node2 = g.edgeList[i][1];

        // Note that when MULTI_PAIRWISE is on, the adjacency matrix contains full integers, not just bits.
        #ifdef MULTI_PAIRWISE
            g.matrix[node1][node2] = g.matrix[node2][node1] = g.edgeList[i][2];
        #else
            g.matrix[node1][node2] = g.matrix[node2][node1] = true;
        #endif

        // Self-loop
        if(node1 == node2) {
            g.adjLists[node1].push_back(node1);
        }else{
            g.adjLists[node1].push_back(node2);
            g.adjLists[node2].push_back(node1);
        }
    }

    /*------------------------------- Init rest of graph --------------------------------- */
    g.lockedList = vector<bool> (nodeLen, false);
    g.lockedTo = vector<string> (nodeLen, "");
    if(bipartite)
        g.updateUnlockedGeneCount();
    g.initConnectedComponents();
}



//transform format
void Graph::edgeList2gw(string fin, string fout) {

  vector<string> nodes;
  unordered_map<string,uint> nodeName2IndexMap;
  vector<vector<string> > edges = fileToStringsByLines(fin);

  nodes.reserve(14000);
  nodeName2IndexMap.reserve(1657);

  // TODO set node types here directly instead

  for(unsigned i = 0; i < edges.size(); i++){
      string node1 = edges[i][0];
      string node2 = edges[i][1];

      if(nodeName2IndexMap.find(node1) != nodeName2IndexMap.end()){
          nodeName2IndexMap[node1] = nodes.size();
          nodes.push_back(node1);
      }

      if(nodeName2IndexMap.find(node2) != nodeName2IndexMap.end()){
          nodeName2IndexMap[node2] = nodes.size();
          nodes.push_back(node2);
      }


  }

// #ifdef MULTI_PAIRWISE
//     vector<string> t_nodes = fileToStrings(fin);
//     for (int i = 0; i < t_nodes.size(); i++) {
//         if (i%3 == 2) {
//             continue;
//         }
//         nodes.push_back(t_nodes[i]);
//     }
//     nodes = removeDuplicates(nodes);
// #else
//     nodes = removeDuplicates(fileToStrings(fin));
// #endif

    //uint numNodes = nodes.size();
    nodes.shrink_to_fit();
    // for (uint i = 0; i < numNodes; i++) {
    //     nodeName2IndexMap[nodes[i]] = i;
    // }

#ifdef MULTI_PAIRWISE
    vector<vector<uint>> edgeList(edges.size(), vector<uint> (3));
#else
    vector<vector<uint>> edgeList(edges.size(), vector<uint> (2));
#endif
    stringstream errorMsg;

    for (uint i = 0; i < edges.size(); i++) {
#ifdef MULTI_PAIRWISE
        string edgeValue;
        if (edges[i].size() == 2) {
            edgeValue = '1';
        }
        else if (edges[i].size() == 3) {
            edgeValue = edges[i][2];
        }
        else {
            throw runtime_error("File not in edge-list format: "+fin);
        }
#else
        if (edges[i].size() != 2) {
            throw runtime_error("File not in edge-list format: "+fin);
        }
#endif
        string node1 = edges[i][0];
        string node2 = edges[i][1];
    if(node1 == node2) {
        errorMsg << "self-loops not allowed in file '" << fin << "' node " << node1 << '\n';
        throw runtime_error(errorMsg.str().c_str());
    }
        uint index1 = nodeName2IndexMap[node1];
        uint index2 = nodeName2IndexMap[node2];
        edgeList[i][0] = index1;
        edgeList[i][1] = index2;
#ifdef MULTI_PAIRWISE
        edgeList[i][2] = stoi(edgeValue);
#endif
    }
    saveInGWFormat(fout, nodes, edgeList);
}

string Graph::getName() const {
    return name;
}

Graph::Graph() :
    nodeTypes(vector<int>(0)),
    geneCount(0),
    miRNACount(0),
    unlockedGeneCount(0),
    unlockedmiRNACount(0),
    geneIndexList(vector<uint>(0)),
    miRNAIndexList(vector<uint>(0)),
    edgeList(vector<vector<uint> > (0)),
    matrix(0),
    adjLists(vector<vector<uint> > (0)),
    connectedComponents(vector<vector<uint>>(0)),
    lockedList(vector<bool> (0)),
    lockedTo(vector<string>(0)),
    lockedCount(0),
    nodeNameToIndexMap(unordered_map<string,uint>(0))
    {}

Graph::Graph(const Graph& G) {
    edgeList = vector<vector<uint> > (G.edgeList);
    matrix = Matrix<MATRIX_UNIT> (G.matrix);
    adjLists = vector<vector<uint> > (G.adjLists);
    connectedComponents = vector<vector<uint> > (G.connectedComponents);
    lockedList = vector<bool> (G.lockedList);
    nodeTypes = vector<int> (G.nodeTypes);
    lockedTo = vector<string> (G.lockedTo);
    lockedCount = G.lockedCount;
    nodeNameToIndexMap = G.nodeNameToIndexMap;
    geneCount = G.geneCount;
    miRNACount = G.miRNACount;
    unlockedGeneCount = G.unlockedGeneCount;
    unlockedmiRNACount = G.unlockedmiRNACount;
    geneIndexList = G.geneIndexList;
    miRNAIndexList = G.miRNAIndexList;
}

Graph::Graph(uint n, const vector<vector<uint> > edges) {
    createFolder(autogenFilesFolder());
    adjLists = vector<vector<uint> > (n, vector<uint> (0));
    matrix = Matrix<MATRIX_UNIT> (n);
    edgeList = edges;

    lockedList = vector<bool> (n, false);
    lockedTo = vector<string> (n, "");
    lockedCount = 0;

    nodeTypes = vector<int> (n, -1);

    //only add edges preserved by alignment
    for (const auto& edge: edges) {
        uint node1 = edge[0], node2 = edge[1];
        adjLists[node1].push_back(node2);
        adjLists[node2].push_back(node1);
#ifdef MULTI_PAIRWISE
        matrix[node1][node2] = matrix[node2][node1] = 1;
#else
        matrix[node1][node2] = matrix[node2][node1] = true;
#endif
    }
    updateUnlockedGeneCount();
    initConnectedComponents();
}

uint Graph::getNumNodes() const {
    return adjLists.size();
}

uint Graph::getNumEdges() const {
#if 0
    cout << "Statistics for Graph " << name << endl;
    cout << "adjList.size() = " << adjLists.size() << endl;
    cout << "matrix.size() = " << matrix.size() << endl;
    cout << "edgeList.size() = " << edgeList.size() << endl;
    cout << "nodeNameToIndexMap.size() = " << nodeNameToIndexMap.size() << endl;
    cout << "lockedList.size() = " << lockedList.size() << endl;
    cout << "lockedTo.size() = " << lockedTo.size() << endl;
    cout << "nodeTypes.size() = " << nodeTypes.size() << endl;
    cout << "connectedComponents.size() = " << connectedComponents.size() << endl;
    cout << "miRNACount = " << miRNACount << endl;
    cout << "geneCount = " << geneCount << endl;
    cout << "unlockedGeneCount = " << unlockedGeneCount << endl;
    cout << "unlockedmiRNACount = " << unlockedmiRNACount << endl;
    cout << "lockedCount = " << lockedCount << endl;
#endif
    return edgeList.size();
}

uint Graph::getNumConnectedComponents() const {
    return connectedComponents.size();
}

void Graph::getMatrix(Matrix<MATRIX_UNIT>& matrixCopy) const {
    matrixCopy = matrix;
}

Matrix<MATRIX_UNIT>& Graph::getMatrix() {
    return matrix;
}

const vector<vector<uint>>& Graph::getAdjLists() const {
    return adjLists;
}
const vector<vector<uint>>& Graph::getEdgeList() const {
    return edgeList;
}

Matrix<float>& Graph::getFloatWeights() {
    return floatWeights;
}

void Graph::getAdjLists(vector<vector<uint> >& adjListsCopy) const {
    adjListsCopy = vector<vector<uint> > (adjLists);
}

void Graph::getEdgeList(vector<vector<uint> >& edgeListCopy) const {
    edgeListCopy = edgeList;
}

const vector<vector<uint> >& Graph::getConnectedComponents() const {
    return connectedComponents;
}

void Graph::setMatrix(Matrix<MATRIX_UNIT>& matrixCopy) {
    matrix = matrixCopy;
}

void Graph::setAdjLists(vector<vector<uint> >& adjListsCopy) {
    adjLists = adjListsCopy;
}
void Graph::setEdgeList(vector<vector<uint> >& edgeListCopy) {
    edgeList = edgeListCopy;
}


void Graph::loadGwFile(const string& fileName) {
    //this function could be improved to deal with blank lines and comments
    stringstream errorMsg;

    stdiobuf sbuf = readFileAsStreamBuffer(fileName);
    istream infile(&sbuf);
    string line;
    
    //ignore header
    for (int i = 0; i < 4; ++i)
        getline(infile, line);
    //read number of nodes
    int n;
    if(line == "-2") {
        getline(infile, line);
        istringstream iss2(line);
        (iss2 >> n);
    } else {
        n = stoi(line);
    }
    if (n <= 0) {
        errorMsg << "Failed to read node number: " << line << " read as " << n;
        throw runtime_error(errorMsg.str().c_str());
    }
    //read (and ditch) nodes
    string node;
    for (int i = 0; i < n; ++i) {
        getline(infile, line);
        istringstream iss(line);
        if (!(iss >> node)) {
            errorMsg << "Failed to read node " << i << " of " << n << ": " << line << " (" << node << ")";
            throw runtime_error(errorMsg.str().c_str());
        }
    }
    //read number of edges
    int m;
    getline(infile, line);
    istringstream iss2(line);
    if (!(iss2 >> m)) {
        errorMsg << "Failed to read edge number: " << line;
        throw runtime_error(errorMsg.str().c_str());
    }

    adjLists = vector<vector<uint> > (n, vector<uint>(0));
    matrix = Matrix<MATRIX_UNIT>(n);
#ifdef MULTI_PAIRWISE
    char dump;
    uint edgeValue;
#endif
    edgeList = vector<vector<uint> > (m, vector<uint>(2));
    lockedList = vector<bool> (n, false);
    lockedTo = vector<string> (n, "");
    nodeTypes = vector<int> (n, -1);

    geneCount = miRNACount = 0;

    //read edges
    uint node1;
    uint node2;

    for (int i = 0; i < m; ++i) {
        getline(infile, line);
        istringstream iss(line);
#ifdef MULTI_PAIRWISE
        if (!(iss >> node1 >> node2 >> dump >> dump >> dump)) {
#else
        if (!(iss >> node1 >> node2)) {
#endif
            errorMsg << "Failed to read edge: " << line;
            throw runtime_error(errorMsg.str().c_str());
        }

#ifdef MULTI_PAIRWISE
        if (!(iss >> edgeValue)) {
            errorMsg << "No edge value: " << line;
            edgeValue = 1;
        }
#endif
        node1--; node2--; //-1 because of remapping

        if(matrix[node1][node2] || matrix[node2][node1]){
            errorMsg << "duplicate edges not allowed (in either direction), node numbers are " << node1+1 << " " << node2+1 << '\n';
	    //errorMsg << "In graph [" << graphName << "]: duplicate edges not allowed (in either direction), node names are " << nodeName2IndexMap[node1+1] << " " << nodeName2IndexMap[node2+1] << '\n';
            throw runtime_error(errorMsg.str().c_str());
        }
        if(node1 == node2) {
            errorMsg << "self-loops not allowed, node number " << node1+1 << '\n';
            throw runtime_error(errorMsg.str().c_str());
        }
        edgeList[i][0] = node1;
        edgeList[i][1] = node2;

#ifdef MULTI_PAIRWISE
        matrix[node1][node2] = matrix[node2][node1] = edgeValue;
#else
        matrix[node1][node2] = matrix[node2][node1] = true;
#endif
        adjLists[node1].push_back(node2);
        adjLists[node2].push_back(node1);
    }
    initConnectedComponents();
}

void Graph::multGwFile(const string& fileName, uint path) {
    //this function could be improved to deal with blank lines and comments
    stringstream errorMsg;

    stdiobuf sbuf = readFileAsStreamBuffer(fileName);
    istream infile(&sbuf);
    string line;
    //ignore header
    for (int i = 0; i < 4; i++) getline(infile, line);
    //read number of nodes
    uint n;
    getline(infile, line);
    istringstream iss(line);
    if (!(iss >> n) or n <= 0) {
        errorMsg << "Failed to read node number: " << line;
        throw runtime_error(errorMsg.str().c_str());
    }
    //read (and ditch) nodes
    string node;
    for (uint i = 0; i < n; i++) {
        getline(infile, line);
        istringstream iss(line);
        if (!(iss >> node)) {
            errorMsg << "Failed to read node " << i << " of " << n << ": " << line << " (" << node << ")";
            throw runtime_error(errorMsg.str().c_str());
        }
    }
    //read number of edges
    uint m;
    getline(infile, line);
    istringstream iss2(line);
    if (!(iss2 >> m)) {
        errorMsg << "Failed to read edge number: " << line;
        throw runtime_error(errorMsg.str().c_str());
    }
    SparseMatrix<uint> sparse_graph1(n);
    SparseMatrix<uint> sparse_graph2(n);

    adjLists = vector<vector<uint> > (n, vector<uint>(0));
    matrix = Matrix<MATRIX_UNIT>(n);
    //edgeList = vector<vector<uint> > (m, vector<uint>(2));
    lockedList = vector<bool> (n, false);
    lockedTo = vector<string> (n, "");
    nodeTypes = vector<int> (n, -1);

    //read edges
    for (uint i = 0; i < m; i++) {
        getline(infile, line);
        istringstream iss(line);
        uint node1, node2;
        if (!(iss >> node1 >> node2)) {
            errorMsg << "Failed to read edge: " << line;
            throw runtime_error(errorMsg.str().c_str());
        }
        sparse_graph1[node1][node2] = sparse_graph1[node2][node1] = 1;
        sparse_graph2[node1][node2] = sparse_graph2[node2][node1] = 1;
    }
    for(uint i=0; i<path ; i++){
        SparseMatrix<uint> final = sparse_graph2.multiply(sparse_graph1);
        for(uint k=0;k<n;k++){
            for(uint j=0;j<n;j++){
                sparse_graph2[k][j] = final[k][j];
            }
        }
    }
    uint elements = 0;
    for(uint k=0;k<n;k++){
            for(uint j=0;j< n;j++){
                if(sparse_graph2[k][j] > 0){
                    elements++;
                }
            }
    }

    edgeList = vector<vector<uint> > (elements, vector<uint>(2));
    uint count = 0;
    for(uint i=0;i<n;i++){
        for(uint j=0;j<n;j++){
            if(sparse_graph2.get(i,j) > 0){
                matrix[i][j] = matrix[j][i] = true;
                adjLists[i].push_back(j);
                adjLists[j].push_back(i);
                edgeList[count][0] = i;
                edgeList[count][1] = j;
                count++;
            }
        }
    }

    initConnectedComponents();
}

bool comp_vectors(const vector<uint>& a,const vector<uint>& b) {
   return a.size() > b.size();
}

void Graph::initConnectedComponents() {
    uint n = getNumNodes();
    vector<bool> nodesAreChecked(n);

    queue<uint> nodes;
    for (uint i = 0; i < n; ++i) nodes.push(i);

    while (nodes.size() > 0) {
        uint startOfConnected = nodes.front();
        nodes.pop();

        if (nodesAreChecked[startOfConnected]) continue;

        vector<uint> connected;

        queue<uint> neighbors;
        neighbors.push(startOfConnected);

        while (not neighbors.empty()) {
            uint node = neighbors.front();
            neighbors.pop();
            if (nodesAreChecked[node]) continue;

            connected.push_back(node);
            nodesAreChecked[node] = true;

            for (const uint & neighbor: adjLists[node]) {
               if (not nodesAreChecked[neighbor])
                   neighbors.push(neighbor);
            }
        }
        connectedComponents.push_back(connected);
    }
    sort(connectedComponents.begin(), connectedComponents.end(), comp_vectors);
}

uint Graph::numNodeInducedSubgraphEdges(const vector<uint>& subgraphNodes) const {
    unordered_set<uint> nodeSet(subgraphNodes.begin(), subgraphNodes.end());
    uint count = 0;
    for (uint i = 0; i < subgraphNodes.size(); i++) {
        uint node1 = subgraphNodes[i];
        for (uint j = 0; j < adjLists[node1].size(); j++) {
            uint node2 = adjLists[node1][j];
            count += nodeSet.count(node2);
        }
    }
    return count/2;
}

Graph Graph::nodeInducedSubgraph(const vector<uint>& nodes) const {
    uint n = nodes.size();
    vector<uint> rev = reverseMapping(nodes, getNumNodes());
    unordered_set<uint> nodeSet(nodes.begin(), nodes.end());
    Graph G;
    G.adjLists = vector<vector<uint> > (n, vector<uint> (0));
    G.matrix = Matrix<MATRIX_UNIT>(n);
    //only add edges between induced nodes
    for (const auto& edge: edgeList) {
        uint node1 = edge[0], node2 = edge[1];
        if (nodeSet.count(node1) and nodeSet.count(node2)) {
            uint newNode1 = rev[node1];
            uint newNode2 = rev[node2];
            G.adjLists[newNode1].push_back(newNode2);
            G.adjLists[newNode2].push_back(newNode1);
            vector<uint> newEdge(2);
            newEdge[0] = newNode1;
            newEdge[1] = newNode2;
            G.edgeList.push_back(newEdge);
#ifdef MULTI_PAIRWISE
            G.matrix[newNode1][newNode2] = G.matrix[newNode2][newNode1] = matrix.get(node1, node2);
#else
            G.matrix[newNode1][newNode2] = G.matrix[newNode2][newNode1] = true;
#endif
        }
    }
    G.initConnectedComponents();
    return G;
}

void Graph::printStats(int numConnectedComponentsToPrint, ostream& stream) const {
    stream << "n    = " << getNumNodes() << endl;
    stream << "m    = " << getNumEdges() << endl;
    stream << "#connectedComponents = " << getNumConnectedComponents() << endl;
    stream << "Largest connectedComponents (nodes, edges) = ";
    for (int i = 0; i < min(numConnectedComponentsToPrint, getNumConnectedComponents()); i++) {
        const vector<uint>& nodes = getConnectedComponents()[i];
        Graph H = nodeInducedSubgraph(nodes);
        stream << "(" << H.getNumNodes() << ", " << H.getNumEdges() << ") ";
    }
    stream << endl;
}

void Graph::getDistanceMatrix(vector<vector<short> >& dist) const {
#if USE_CACHED_FILES
// By default, USE_CACHED_FILES is 0 and SANA does not cache files. Change USE_CACHED_FILES at your own risk.
    string distMatrixFile = serializedFilesFolder()+name+"_distMatrix.txt";
    if (fileExists(distMatrixFile) && !newerGraphAvailable(path.c_str(), distMatrixFile.c_str())) {
        readMatrixFromFile(dist, getNumNodes(), getNumNodes(), distMatrixFile);
        return;
    }
#endif
    Timer T;
    T.start();
    cout << "Computing "+name+" distance matrix...";
    computeDistanceMatrix(dist);
    cout << "Graph::getDistanceMatrix done (" << T.elapsedString() << ")" << endl;
#if USE_CACHED_FILES
// By default, USE_CACHED_FILES is 0 and SANA does not cache files. Change USE_CACHED_FILES at your own risk.
    writeMatrixToFile(dist, distMatrixFile);
#endif
}

//a -1 indicates that the distance is infinite
//floyd-warshall algorithm
void Graph::computeDistanceMatrix(vector<vector<short> >& dist) const {
    uint n = getNumNodes();
    dist = vector<vector<short> > (n, vector<short> (n, -1));
    assert(false); // replace this with iterated Dijkstra, which is MUCH faster on sparse graphs
    for (uint v = 0; v < n; v++) {
        dist[v][v] = 0;
        for (uint i = 0; i < adjLists[v].size(); i++) {
            uint u = adjLists[v][i];
            dist[u][v] = 1;
        }
    }
    for (uint k = 0; k < n; k++) {
        for (uint i = 0; i < n; i++) {
            for (uint j = 0; j < n; j++) {
                if (dist[i][k] != -1 and dist[k][j] != -1) {
                    if (dist[i][j] == -1 or dist[i][j] > dist[i][k] + dist[k][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }
    }
}

//The first line contains two integers n and e - the number of nodes and edges.
//The following e lines describe undirected edges with space-separated ids of their endpoints.
//Node ids should be between 0 and n-1
void Graph::writeGraphEdgeListFormat(const string& fileName) {
    uint n = getNumNodes();
    uint e = getNumEdges();
    ofstream outfile;
    outfile.open(fileName.c_str());
    outfile << n << " " << e << endl;
    for (uint i = 0; i < e; i++) {
        outfile << edgeList[i][0] << " " << edgeList[i][1] << endl;
    }
    outfile.close();
}

void Graph::writeGraphEdgeListFormatPISWAP(const string& fileName) {
    ofstream outfile;
    uint e = getNumEdges();
    vector<string> nodeNames = getNodeNames();
    outfile.open(fileName.c_str());
    outfile << "INTERACTOR_A INTERACTOR_B" << endl;
    for (uint i = 0; i < e; i++) {
        outfile << nodeNames[edgeList[i][0]] << " " << nodeNames[edgeList[i][1]] << endl;
    }
    outfile.close();
}

void Graph::writeGraphEdgeListFormatNETAL(const string& fileName) {
    uint e = getNumEdges();
    ofstream outfile;
    outfile.open(fileName.c_str());
    for (uint i = 0; i < e; i++) {
        outfile << edgeList[i][0] << "\t" << edgeList[i][1] << endl;
    }
    outfile.close();
}

void Graph::writeGraphEdgeListFormatPINALOG(const string& fileName){
    ofstream outfile;
    uint e = getNumEdges();
    vector<string> nodeNames = getNodeNames();
    outfile.open(fileName.c_str());
    for (uint i = 0; i < e; i++) {
        outfile << nodeNames[edgeList[i][0]] << "\t" << nodeNames[edgeList[i][1]] << endl;
    }
    outfile.close();
}


vector<uint> Graph::getAllNodesAround(uint node, uint maxDist) const {
    uint n = getNumNodes();
    vector<uint> distances(n, n);
    distances[node] = 0;
    queue<uint> Q;
    Q.push(node);
    while (not Q.empty()) {
        uint u = Q.front();
        Q.pop();
        uint dist = distances[u];
        if (dist == maxDist) break;
        for (uint i = 0; i < adjLists[u].size(); i++) {
            uint v = adjLists[u][i];
            if (distances[v] < n) continue;
            distances[v] = dist+1;
            Q.push(v);
        }
    }
    vector<uint> result;
    for (uint i = 0; i < n; i++) {
        if (distances[i] < n and distances[i] >= 0) result.push_back(i);
    }
    return result;
}

vector<uint> Graph::numNodesAround(uint node, uint maxDist) const {
    uint n = getNumNodes();
    vector<uint> distances(n, n);
    distances[node] = 0;
    queue<uint> Q;
    Q.push(node);
    while (not Q.empty()) {
        uint u = Q.front();
        Q.pop();
        uint dist = distances[u];
        if (dist == maxDist) break;
        for (uint i = 0; i < adjLists[u].size(); i++) {
            uint v = adjLists[u][i];
            if (distances[v] < n) continue;
            distances[v] = dist+1;
            Q.push(v);
        }
    }
    vector<uint> result(maxDist, 0);
    uint total = 0;
    for (uint i = 0; i < n; i++)
        if (distances[i] < n and distances[i] > 0) {
	    result[distances[i]-1]++; 
	    total++;
	}
    assert(total == getAllNodesAround(node, maxDist).size());
    return result;
}

vector<uint> Graph::numEdgesAround(uint node, uint maxDist) const {
    uint n = getNumNodes();
    vector<uint> distances(n, n);
    vector<bool> visited(n, false);
    distances[node] = 0;
    queue<uint> Q;
    Q.push(node);
    vector<uint> result(maxDist, 0);
    while (not Q.empty()) {
        uint u = Q.front();
        Q.pop();
        uint dist = distances[u];
        if (dist == maxDist) break;
        for (uint i = 0; i < adjLists[u].size(); i++) {
            uint v = adjLists[u][i];
            if (not visited[v]) result[dist]++;
            if (distances[v] < n) continue;
            distances[v] = dist+1;
            Q.push(v);
        }
        visited[u] = true;
    }
    return result;
}

uint Graph::randomNode() {
    return randInt(0, getNumNodes()-1);
}

//note: does not update CCs
void Graph::addEdge(uint node1, uint node2) {
    matrix[node1][node2] = matrix[node2][node1] = true;
    vector<uint> edge(2);
    edge[0] = node1;
    edge[1] = node2;
    edgeList.push_back(edge);
    adjLists[node1].push_back(node2);
    adjLists[node2].push_back(node1);
}

//note: does not update CCs
void Graph::removeEdge(uint node1, uint node2) {
    matrix[node1][node2] = matrix[node2][node1] = false;
    uint m = getNumEdges();
    //update edge list
    for (uint i = 0; i < m; i++) {
        if ((edgeList[i][0] == node1 and edgeList[i][1] == node2) or
            (edgeList[i][0] == node2 and edgeList[i][1] == node1)) {
            vector<uint> lastEdge = edgeList[m-1];
            edgeList[i] = lastEdge;
            edgeList.pop_back();
            break;
        }
    }
    //update adjacency lists
    for (uint i = 0; i < adjLists[node1].size(); i++) {
        if (adjLists[node1][i] == node2) {
            uint lastNeighbor = adjLists[node1][adjLists[node1].size()-1];
            adjLists[node1][i] = lastNeighbor;
            adjLists[node1].pop_back();
            break;
        }
    }
    for (uint i = 0; i < adjLists[node2].size(); i++) {
        if (adjLists[node2][i] == node1) {
            uint lastNeighbor = adjLists[node2][adjLists[node2].size()-1];
            adjLists[node2][i] = lastNeighbor;
            adjLists[node2].pop_back();
            break;
        }
    }
}

//note: does not update CCs
void Graph::addRandomEdge() {
    uint node1 = 0, node2 = 0;
    while (node1 == node2 or matrix.get(node1, node2)) {
        node1 = randomNode();
        node2 = randomNode();
    }
    addEdge(node1, node2);
}

//note: does not update CCs
void Graph::removeRandomEdge() {
    uint node1 = 0, node2 = 0;
    while (node1 == node2 or not matrix.get(node1, node2)) {
        node1 = randomNode();
        node2 = randomNode();
    }
    removeEdge(node1, node2);
}

void Graph::addRandomEdges(double addedEdgesProportion) {
    uint n = (double) getNumNodes() * addedEdgesProportion;
    for (uint i = 0; i <= n; i++) {
        addRandomEdge();
    }
    initConnectedComponents();
}

void Graph::removeRandomEdges(double removedEdgesProportion) {
    uint n = (double) getNumNodes() * removedEdgesProportion;
    for (uint i = 0; i <= n; i++) {
        removeRandomEdge();
    }
    initConnectedComponents();
}

void Graph::rewireRandomEdges(double rewiredEdgesProportion) {
    uint n = (double) getNumEdges() * rewiredEdgesProportion;
    for (uint i = 0; i <= n; i++) {
        addRandomEdge();
        removeRandomEdge();
    }
    initConnectedComponents();
}

string Graph::autogenFilesFolder() {
    return AUTOGENEREATED_FILES_FOLDER;
}
string Graph::serializedFilesFolder() {
    return autogenFilesFolder()+"serialized/";
}
vector<vector<uint> > Graph::loadGraphletDegreeVectors() {
    std::ostringstream oss;
    oss << Graph::maxGraphletSize;
    string subfolder = "gdv" + oss.str() + "/";
    createFolder(autogenFilesFolder() + subfolder);
    string gdvsFileName = autogenFilesFolder() + subfolder + "/"+ name + "_gdv"+oss.str()+".bin";
    uint n = getNumNodes();
    if (fileExists(gdvsFileName) && !newerGraphAvailable(path.c_str(), gdvsFileName.c_str())) {
        vector<vector<uint> > gdvs;
        if(maxGraphletSize == 4){
            gdvs.assign(n, vector<uint>(15));
        }else{//it is either 4 or 5
            gdvs.assign(n, vector<uint>(73));
        }
        readMatrixFromBinaryFile(gdvs, gdvsFileName);
        return gdvs;
    }
    cout << "Computing " << gdvsFileName << " ... ";
    Timer T;
    T.start();
    vector<vector<uint> > gdvs = computeGraphletDegreeVectors();
    cout << "Graph::loadGraphletDegreeVectors done (" << T.elapsedString() << ")" << endl;
    writeMatrixToBinaryFile(gdvs, gdvsFileName);
    string readeableVersionFile = autogenFilesFolder() + subfolder + name + "_gdv"+ oss.str() + ".txt";
    writeMatrixToFile(gdvs, readeableVersionFile);
    return gdvs;
}

vector<vector<uint> > Graph::computeGraphletDegreeVectors() {
    std::cout<<"Computing Graphlet Degree Vectors... "<<endl;
    uint n = getNumNodes();
    uint m = getNumEdges();

    FILE *fp = tmpfile();
    fprintf(fp, "%d %d\n",n,m); // fout << n << " " << m << endl;
    for (uint i = 0; i < m; i++) {
        fprintf(fp, "%d %d\n", edgeList[i][0], edgeList[i][1]);
    }
    rewind(fp); // because computeGraphlets is going to start reading the file from the beginning.
    double GraphletSizemax = Graph::maxGraphletSize;

    vector<vector<uint> > gdvs = computeGraphlets(GraphletSizemax, fp);
    fclose(fp);
    return gdvs;
}

unordered_map<string,uint> Graph::getNodeNameToIndexMap() const {
    if(nodeNameToIndexMap.size() != 0){
      return nodeNameToIndexMap;
    }

    string networkFile = "networks/"+name+"/"+name+".gw";
    if(this -> path != "")
        networkFile = this -> path;

    stdiobuf sbuf = readFileAsStreamBuffer(networkFile);
    istream infile(&sbuf);
    string line;
    //ignore header
    for (int i = 0; i < 4; i++) getline(infile, line);
    //read number of nodes
    int n;
    if(line == "-2") {
    getline(infile, line);
    istringstream iss2(line);
    (iss2 >> n);
    } else {
    n = stoi(line);
    }
    if (n <= 0) {
        throw runtime_error("Failed to read node number: " + line);
    }

    //read nodes
    unordered_map<string, uint> res;
    string node;
    for (uint i = 0; i < (uint) n; i++) {
        getline(infile, line);
        istringstream iss(line);
        if (!(iss >> node)) {
            throw runtime_error("Failed to read node "+intToString(i)+" of "+intToString(n)+": "+line+" ("+node+")");
        }
        node = node.substr(2,node.size()-4); //strip |{ and }|
        res[node] = i;
    }
    return res;
}

unordered_map<uint,string> Graph::getIndexToNodeNameMap() const {
    unordered_map<string,uint> reverse = getNodeNameToIndexMap();
    unordered_map<uint,string> res;
    for (const auto &nameIndexPair : reverse ) {
        res[nameIndexPair.second] = nameIndexPair.first;
    }
    return res;
}

bool Graph::hasSelfLoop(uint source) const {
#ifdef SPARSE
    vector<uint> neighbors = adjLists[source];
    return std::find(neighbors.begin(), neighbors.end(), source) != neighbors.end();
#else
    return (matrix.get(source, source)); // || (std::find(neighbors.begin(), neighbors.end(), source) != neighbors.end());
#endif
}

vector<string> Graph::getNodeNames() const {
    vector<string> result(getNumNodes());
    unordered_map<uint,string> map = getIndexToNodeNameMap();
    for (uint i = 0; i < getNumNodes(); i++) {
        result[i] = map[i];
    }
    return result;
}

vector<uint> Graph::degreeDistribution() const {
    uint n = getNumNodes();
    uint maxDegree = adjLists[0].size();
    for (uint i = 1; i < n; i++) {
        if (adjLists[i].size() > maxDegree) maxDegree = adjLists[i].size();
    }
    vector<uint> res(maxDegree+1);
    for (uint i = 0; i < n; i++) {
        res[adjLists[i].size()]++;
    }
    return res;
}

double Graph::getAverageDistance() const {
    vector<vector<short> > dists;
    getDistanceMatrix(dists);
    uint n = getNumNodes();
    double distSum = 0;
    double distCount = 0;
    for (uint i = 0; i < n; i++) {
        for (uint j = i+1; j < n; j++) {
            if (dists[i][j] > 0) {
                distSum += dists[i][j];
                distCount++;
            }
        }
    }
    return distSum/distCount;
}

struct Point {
    double x;
    double y;
    double z;

    Point(double x, double y, double z): x(x), y(y), z(z) {}

    double distOrigin() {
        return sqrt(x*x + y*y + z*z);
    }

    void normalize() {
        double l = distOrigin();
        x/=l; y/=l; z/=l;
    }

    static Point randomNormalizedPoint() {
        Point p(randDouble(), randDouble(), randDouble());
        p.normalize();
        return p;
    }

    double dist(const Point& p) {
        double a = x-p.x;
        double b = y-p.y;
        double c = z-p.z;
        return sqrt(a*a+b*b+c*c);
    }
};

struct Sphere {
    Point center;
    double radius;
    Sphere(Point center, double radius): center(center), radius(radius) {}

    Point randomContainedPoint() {
        Point p = Point::randomNormalizedPoint();
        double dist = radius*pow(randDouble(),1./3.);
        p.x *= dist; p.y *= dist; p.z *= dist;
        p.x += center.x; p.y += center.y; p.z += center.z;
        return p;
    }
};

//model GEO-GD expansion from paper:
//GEOMETRIC EVOLUTIONARY DYNAMICS OF PROTEIN INTERACTION NETWORKS
void Graph::GeoGeneDuplicationModel(uint numNodes, uint numEdges, string outputFile) {
    if (numNodes < 5)
        cerr << "The minimum number of nodes is 5";
    const double epsilon = 1;
    //initial network
    Point center = Point(0,0,0);
    Sphere sphere(center, epsilon/2);
    vector<Point> points(5, sphere.randomContainedPoint());
    //add nodes
    for (uint i = 5; i < numNodes; i++) {
        uint parentIndex = randMod(i);
        Point p = points[parentIndex];
        Point dir = Point::randomNormalizedPoint();
        double dist = randDouble()*2*epsilon;
        p.x += dist*dir.x;
        p.y += dist*dir.y;
        p.z += dist*dir.z;
        points.push_back(p);
    }
    //add edges
    long long unsigned int numDists = (numNodes*(numNodes-1))/2;
    vector<double> dists(numDists, -1);
    long long unsigned int count = 0;
    for (uint i = 0; i < numNodes; i++) {
        for (uint j = 0; j < i; j++) {
            dists[count] = points[i].dist(points[j]);
            count++;
       }
    }
    sort(dists.begin(), dists.end());
    double cutOffDist = dists[numEdges];

    ofstream outfile;
    outfile.open(outputFile.c_str());
    //header
    outfile << "LEDA.GRAPH" << endl;
    outfile << "string" << endl;
    outfile << "short" << endl;
    outfile << "-2" << endl;
    outfile << numNodes << endl;
    for (uint i = 0; i < numNodes; i++) {
        outfile << "|{node" << i+1 << "}|" << endl;
    }
    outfile << numEdges << endl;
    for (uint i = 0; i < numNodes; i++) {
        for (uint j = 0; j < i; j++) {
            if (points[i].dist(points[j]) < cutOffDist) {
                outfile << j+1 << " " << i+1 << " |{}|" << endl;
            }
        }
    }
    outfile << endl;
}

void writeGWHeader(ofstream& outfile) {
    outfile << "LEDA.GRAPH" << endl;
    outfile << "string" << endl;
    outfile << "short" << endl;
    outfile << "-2" << endl;
}

void writeGWNodes(ofstream& outfile, const vector<string>& nodeNames) {
    uint numNodes = nodeNames.size();
    outfile << numNodes << endl;
    for (uint i = 0; i < numNodes; i++) {
        outfile << "|{" << nodeNames[i] << "}|" << endl;
    }
}

void writeGWEdges(ofstream& outfile, const vector<vector<uint>>& edgeList) {
    uint numEdges = edgeList.size();
    outfile << numEdges << endl;
    for (uint i = 0; i < numEdges; i++) {
#ifdef MULTI_PAIRWISE
        outfile << edgeList[i][0]+1 << " " << edgeList[i][1]+1 << " 0 |{";
        outfile << edgeList[i][2] << "}|" << endl;
#else
        outfile << edgeList[i][0]+1 << " " << edgeList[i][1]+1 << " 0 |{}|" << endl;
#endif
    }
}

void Graph::saveInGWFormat(string outputFile, const vector<string>& nodeNames,
    const vector<vector<uint>>& edgeList) {
    ofstream outfile;
    string pid = to_string(getpid()), saveIn = "/tmp/saveInGWFormat";
    string tempFile = saveIn+pid;
    outfile.open(tempFile.c_str());
    writeGWHeader(outfile);
    writeGWNodes(outfile, nodeNames);
    writeGWEdges(outfile, edgeList);
    outfile.close();
    exec("mv "+tempFile+" "+outputFile);
}

void Graph::saveInGWFormatShuffled(string outputFile, const vector<string>& nodeNames,
    const vector<vector<uint>>& edgeList) {

    uint n = nodeNames.size();
    vector<uint> origPos2NewPos(n);
    for (uint i = 0; i < n; i++) origPos2NewPos[i] = i;
    randomShuffle(origPos2NewPos);

    unordered_map<uint, uint> newPos2OrigPos;
    newPos2OrigPos.reserve(n);
    for (uint i = 0; i < n; i++) {
        newPos2OrigPos[origPos2NewPos[i]] = i;
    }

    vector<string> newNodeNames(n);
    for (uint i = 0; i < n; i++) {
        newNodeNames[i] = nodeNames[newPos2OrigPos[i]];
    }

    uint m = edgeList.size();
    vector<vector<uint>> newEdgeList(m, vector<uint> (2));
    for (uint i = 0; i < m; i++) {
        newEdgeList[i][0] = origPos2NewPos[edgeList[i][0]];
        newEdgeList[i][1] = origPos2NewPos[edgeList[i][1]];
    }
    saveInGWFormat(outputFile, newNodeNames, newEdgeList);
}

//assumes the gw file for this graph does not already exist
//so we create new node names
void Graph::saveInGWFormat(string outputFile) {
    uint numNodes = getNumNodes();
    vector<string> nodeNames(numNodes);
    for (uint i = 0; i < numNodes; i++) {
        nodeNames[i] = "node"+intToString(i);
    }
    saveInGWFormat(outputFile, nodeNames, edgeList);
}

void Graph::saveInGWFormatWithNames(string outputFile) {
    saveInGWFormat(outputFile, getNodeNames(), edgeList);
}

void Graph::saveInShuffledOrder(string outputFile) {
    uint numNodes = getNumNodes();
    unordered_map<uint,string> index2Name = getIndexToNodeNameMap();
    vector<string> nodeNames(numNodes);
    for (uint i = 0; i < numNodes; i++) {
        nodeNames[i] = index2Name[i];
    }
    saveInGWFormatShuffled(outputFile, nodeNames, edgeList);
}

void Graph::saveGraphletsAsSigs(string outputFile) {
    std::vector<std::vector<uint>> graphlets = computeGraphletDegreeVectors();
    vector<string> nodeNames = getNodeNames();
    ofstream out;
    out.open(outputFile.c_str());
     for (unsigned int i = 0; i < nodeNames.size(); i++) {
         out << nodeNames[i] << "\t";

         for (int j = 0; j < 73; j++) {
             out << graphlets[i][j] << "\t";
         }
         out << std::endl;
     }

     out.close();
}

Graph Graph::randomNodeInducedSubgraph(uint numNodes) {
    uint n = getNumNodes();
    if (numNodes > n)
        cerr << "the subgraph cannot have more nodes" << endl;
    vector<uint> v(getNumNodes());
    for (uint i = 0; i < n; i++) v[i] = i;
    randomShuffle(v);
    v = vector<uint> (v.begin(), v.begin()+numNodes);
    return nodeInducedSubgraph(v);
}

Graph Graph::randomNodeShuffle(vector<uint> &shuffle) {
    uint n = getNumNodes();
    for (uint i = 0; i < n; i++) shuffle[i] = i;
    assert(shuffle.size() == n);
    randomShuffle(shuffle);
    shuffle = vector<uint> (shuffle.begin(), shuffle.end());
    return nodeInducedSubgraph(shuffle);
}

bool Graph::isWellDefined() {
    bool isWellDefined = true;
    //check that adj lists don't have repeated entries
    //check that all indices in adj lists are within bounds
    //check that every edge in the adj lists appears in the adj matrix
    //check that no node is neighbor to itself in the adj lists
    uint numNodes = matrix.size();
    for (uint i = 0; i < adjLists.size(); i++) {
        for (uint j = 0; j < adjLists[i].size(); j++) {
            uint neighbor = adjLists[i][j];
            if (neighbor < 0 or neighbor >= numNodes) {
                cerr << "Adjacency list ill defined: node " << i << " adjacent to ";
                cerr << "node out of range " << neighbor << endl;
                isWellDefined = false;
            }
            if (neighbor == i) {
                cerr  << "Adjacency list ill defined: node " << i << " adjacent to itself" << endl;
                isWellDefined = false;

            }
            if (not matrix.get(i, neighbor) or not matrix.get(i, neighbor)) {
                cerr << "node " << i << " adjacent to node " << matrix.get(i, neighbor);
                cerr << " in the adj lists but not on the adj matrix" << endl;
                isWellDefined = false;
            }
            for (uint k = j+1; k < adjLists[i].size(); k++) {
                if (neighbor == adjLists[i][k]) {
                    cerr << "Adjacency list ill defined: node " << i << " adjacent to ";
                    cerr << neighbor << " twice" << endl;
                    isWellDefined = false;
                }
            }
        }
    }
    //check that no node is adj to itself in the adj matrix
    for (uint i = 0; i < numNodes; i++) {
        if (matrix.get(i, i)) {
            cerr << "Adjacency matrix ill defined: node " << i << " adjacent to itself" << endl;
            isWellDefined = false;
        }
    }
    //check that adj matrix is symmetric
    //check that every edge in the adj matrix appears in the adj lists (twice)
    for (uint i = 0; i < numNodes; i++) {
        for (uint j = 0; j < i; j++) {
            if (matrix.get(i, j) != matrix.get(j, i)) {
                cerr << "Adjacency matrix ill defined: node (" << i << "," << j;
                cerr << ") is not symmetric" << endl;
                isWellDefined = false;
            }
            if (matrix.get(i, j)) {
                bool found = false;
                for (uint k = 0; not found and k < adjLists[i].size(); k++) {
                    if (adjLists[i][k] == j) {
                        found = true;
                    }
                }
                if (not found) {
                    cerr << "Node " << i << " adjacent to node " << j << " in adjacency";
                    cerr << " matrix but not adjacency lists" << endl;
                    isWellDefined = false;
                }
                found = false;
                for (uint k = 0; not found and k < adjLists[j].size(); k++) {
                    if (adjLists[j][k] == i) {
                        found = true;
                    }
                }
                if (not found) {
                    cerr << "Node " << i << " adjacent to node " << j << " in adjacency";
                    cerr << " matrix but not adjacency lists" << endl;
                    isWellDefined = false;
                }
            }
        }
    }
    //check that edge list does not have repeated entries
    //check no node is adjacent to itself in the edge list
    //check all indices in range
    //check that every edge in edge list appears in the adj matrix
    for (uint i = 0; i < edgeList.size(); i++) {
        if (edgeList[i][0] == edgeList[i][1]) {
            cerr << "Edge list ill defined: node " << edgeList[i][0];
            cerr << " adjacent to itself" << endl;
            isWellDefined = false;
        }
        if (edgeList[i][0] < 0 or edgeList[i][0] >= numNodes or
            edgeList[i][1] < 0 or edgeList[i][1] >= numNodes) {
            cerr << "Edge list ill defined: node out of range" << edgeList[i][0] << endl;
            isWellDefined = false;
        }
        if (not matrix.get(edgeList[i][0], edgeList[i][1])) {
            cerr << "Nodes " << edgeList[i][0] << " and " << edgeList[i][1];
            cerr << " adjacent in the edge list but not in the adjacency matrix" << endl;
            isWellDefined = false;
        }
        for (uint j = 0; j < i; j++) {
            if (edgeList[i][0] == edgeList[j][0] and edgeList[i][1] == edgeList[j][1]) {
                cerr << "Edge list ill defined: edge (" << edgeList[i][0] << ",";
                cerr << edgeList[i][1] << ") is repeated" << endl;
                isWellDefined = false;
            }
            if (edgeList[i][0] == edgeList[j][1] and edgeList[i][1] == edgeList[j][0]) {
                cerr << "edge list ill defined: edge (" << edgeList[i][0] << ",";
                cerr << edgeList[i][1] << ") is repeated" << endl;
                isWellDefined = false;
            }
        }
    }
    //check that every edge in adj matrix appears in the edge list
    for (uint i = 0; i < numNodes; i++) {
        for (uint j = 0; j < i; j++) {
            if (matrix.get(i, j)) {
                bool found = false;
                for (uint k = 0; not found and k < edgeList.size(); k++) {
                    if ((edgeList[k][0] == i and edgeList[k][1] == j) or
                        (edgeList[k][1] == i and edgeList[k][0] == j))
                        found = true;
                }
                if (not found) {
                    cerr << "Node " << i << " adjacent to node " << j << " in adjacency";
                    cerr << " matrix but not in edge list" << endl;
                    isWellDefined = false;
                }
            }
        }
    }
    return isWellDefined;
}

//returns whether this graph and other have exactly the
//same set of node names
bool Graph::sameNodeNames(const Graph& other) const {
    vector<string> thisNames = getNodeNames();
    vector<string> otherNames = other.getNodeNames();
    set<string> s1(thisNames.begin(), thisNames.end());
    set<string> s2(otherNames.begin(), otherNames.end());
    return s1 == s2;
}


void Graph::setLockedList(vector<string>& nodes, vector<string> & pairs){
    unordered_map<string,uint> nodeMap = getNodeNameToIndexMap();
    const int size = nodeMap.size();
    vector<bool> locked (size, false);
    vector<string> lockPairs (size, "");
    for(uint i = 0; i < nodes.size(); i++){
        uint index = nodeMap[nodes[i]];
        locked[index] = true;
        lockPairs[index] = pairs[i];
    }
    lockedList = locked;
    lockedTo = lockPairs;
    lockedCount = nodes.size();
    updateUnlockedGeneCount();
}

vector<bool>& Graph::getLockedList(){
    return lockedList;
}
bool Graph::isLocked(uint index) const
{
    return lockedList[index];
}

string Graph::getLockedTo(uint index){
    return lockedTo[index];
}

int Graph::getLockedCount(){
    return lockedCount;
}

/**
 * Puts the unlocked nodes at beginning and the locked ones at the end
 *
 * For example if we have nodes 1,2,3,4,5 with 3,5 being locked they get reIndexed to
 * 1,2,3,4,5 -> 1,2,5,3,4
 */
unordered_map<uint, uint> Graph::getLocking_ReIndexMap() const{
    unordered_map<uint, uint> result;
    int n = getNumNodes();
    result.reserve(n);
    int unlockedIndex = 0;
    int lockedIndex = n-1;
    for(int i=0; i<n; i++){
        if(isLocked(i))
            result[i] = lockedIndex--;
        else
            result[i] = unlockedIndex++;
    }
    assert(lockedIndex == n - lockedCount - 1  and unlockedIndex == n - lockedCount);
    return result;
}


/** This is used for -bipartite,
 *   -- it also support locking so if both locking and  bipartite is turned on this reIndexing is used
 *
 *   Reindexing as following order:
 *         gene, miRNA, Locked gene or miRNA
 *
 */
unordered_map<uint, uint> Graph::getBipartiteNodeTypes_ReIndexMap() const{
    unordered_map<uint, uint> result;
    int n = getNumNodes();
    result.reserve(n);
    int unlocked_gene_count = 0;
    int unlocked_miRNA_count = 0;
    for(int i=0;i<n;i++){
        if(!isLocked(i)){
            if(nodeTypes[i] == Graph::NODE_TYPE_GENE) //"gene")
                unlocked_gene_count++;
            else if (nodeTypes[i] == Graph::NODE_TYPE_MIRNA)//"miRNA")
                unlocked_miRNA_count++;
        }
    }
    assert (unlocked_gene_count + unlocked_miRNA_count == n - lockedCount);

    int lockedIndex = n-1;
    int unlocked_gene_index = 0;
    int unlocked_miRNA_index = unlocked_gene_count;
    for(int i=0;i<n;i++){
        if(isLocked(i))
            result[i] = lockedIndex--;
        else if(nodeTypes[i] == Graph::NODE_TYPE_GENE)//"gene")
            result[i] = unlocked_gene_index++;
        else if(nodeTypes[i] == Graph::NODE_TYPE_MIRNA)//"miRNA")
            result[i] = unlocked_miRNA_index++;
    }
    assert(lockedIndex == n - lockedCount - 1
         and unlocked_gene_index == unlocked_gene_count
         and unlocked_miRNA_index == n - lockedCount );
    return result;
}

void Graph::reIndexGraph(unordered_map<uint, uint> reIndexMap){
    uint n = getNumNodes();
    Matrix<MATRIX_UNIT> matrixCopy(n);
    for (uint i = 0; i < n; i++) {
         for (uint j = 0; j < n; j++){
               uint a = reIndexMap[i];
               uint b = reIndexMap[j];
               matrixCopy[a][b] = matrix[i][j];
         }
     }
    matrix = matrixCopy;

    // Adj List
    vector<vector<uint> > adjListsCopy(n, vector<uint> (0));
    for (uint i = 0; i < n; i++) {
       for(uint j= 0; j < adjLists[i].size(); j++){
           uint a = reIndexMap[i];
           uint b = reIndexMap[adjLists[i][j]];
           adjListsCopy[a].push_back(b);
       }
     }
    adjLists = adjListsCopy;


    // Edge List
    uint m = edgeList.size();
    for(uint i = 0; i < m; i++){
        edgeList[i][0] = reIndexMap[edgeList[i][0]];
        edgeList[i][1] = reIndexMap[edgeList[i][1]];
    }

    updateUnlockedGeneCount();
    initConnectedComponents();
}

bool Graph::isBipartite(){
    //return geneCount > 0 || miRNACount > 0;
    return bipartiteEnabled;
}

int Graph::getNumMultipartite() {
    return multipartite;
}

int Graph::getBipartiteNodeType(uint i){
    return nodeTypes[i];
}

void Graph::updateUnlockedGeneCount(){
   if(!bipartiteEnabled)
        return;

   unlockedGeneCount = 0;
   unlockedmiRNACount = 0;
   int n = getNumNodes();
   for(int i=0;i<n;i++){
       if(!isLocked(i)){
           if(nodeTypes[i] == Graph::NODE_TYPE_GENE)//"gene")
               unlockedGeneCount++;
           else if(nodeTypes[i] == Graph::NODE_TYPE_MIRNA)// "miRNA")
               unlockedmiRNACount++;
       }
   }
}
#ifdef MULTI_PAIRWISE
uint Graph::getWeightedNumEdges() {
    if (weightedNumEdges != 0) return weightedNumEdges;
    weightedNumEdges = 0;
    for (auto c : edgeList)
        weightedNumEdges += matrix.get(c[0], c[1]);
    return weightedNumEdges;
}
#endif

bool Graph::hasFloatWeight() const {
    return parseFloatWeight;
}
